<?php
/**
 * Leave
 *
 * PHP version 8.1
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Staffology Payroll API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: duane@staffology.co.uk
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Staffology\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use SynergiTech\Staffology\ObjectSerializer;

/**
 * Leave Class Doc Comment
 *
 * @description Used to represent Leave, including Holiday and Statutory leave (such as Maternity Leave)
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class Leave implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = 'Leave';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'providerId' => '\SynergiTech\Staffology\Model\ExternalDataProviderId',
        'externalId' => 'string',
        'type' => '\SynergiTech\Staffology\Model\LeaveType',
        'pay' => '\SynergiTech\Staffology\Model\LeavePayType',
        'payFrequency' => '\SynergiTech\Staffology\Model\StatPayFrequency',
        'payRunExistsWithStatPay' => 'bool',
        'from' => '\DateTime',
        'to' => '\DateTime',
        'notes' => 'string',
        'averageWeeklyEarnings' => 'float',
        'automaticAWECalculation' => 'bool',
        'babyDate' => '\DateTime',
        'secondaryBabyDate' => '\DateTime',
        'tertiaryBabyDate' => '\DateTime',
        'overridePaymentDescription' => 'bool',
        'overridenPaymentDescription' => 'string',
        'workingDays' => 'float',
        'workingDaysOverride' => 'float',
        'totalDays' => 'float',
        'totalDaysOverride' => 'float',
        'useAssumedPensionablePay' => 'bool',
        'assumedPensionablePays' => '\SynergiTech\Staffology\Model\LeaveAssumedPensionablePay[]',
        'offsetPay' => 'bool',
        'sspPayFromDayOne' => 'bool',
        'linkedPiw' => '\SynergiTech\Staffology\Model\LinkedPiw',
        'kitSplitDays' => '\DateTime[]',
        'historicSspRequiresProcessing' => 'bool',
        'historicSxpRequiresProcessing' => 'bool',
        'openingPay' => 'float',
        'useOpeningPay' => 'bool',
        'historicOspRequiresProcessing' => 'bool',
        'historicOmpRequiresProcessing' => 'bool',
        'historicSmpRequiresProcessing' => 'bool',
        'occupationalMaternityPolicyUniqueId' => 'string',
        'openingOmpPay' => 'float',
        'payRunExistsWithOccMaternityPay' => 'bool',
        'calculationType' => '\SynergiTech\Staffology\Model\LeaveCalculationType',
        'strikeHoursToDeduct' => 'float',
        'customPayments' => '\SynergiTech\Staffology\Model\LeaveCustomPayment[]',
        'customProRataRules' => '\SynergiTech\Staffology\Model\LeaveCustomProRataRule[]',
        'lastProcessedFrom' => '\DateTime',
        'isReversed' => 'bool',
        'paymentTier' => '\SynergiTech\Staffology\Model\NeonatalCarePaymentTier',
        'documentCount' => 'int',
        'documents' => '\SynergiTech\Staffology\Model\Item[]',
        'employee' => '\SynergiTech\Staffology\Model\Item',
        'id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'providerId' => null,
        'externalId' => null,
        'type' => null,
        'pay' => null,
        'payFrequency' => null,
        'payRunExistsWithStatPay' => null,
        'from' => 'date-time',
        'to' => 'date-time',
        'notes' => null,
        'averageWeeklyEarnings' => 'double',
        'automaticAWECalculation' => null,
        'babyDate' => 'date',
        'secondaryBabyDate' => 'date',
        'tertiaryBabyDate' => 'date',
        'overridePaymentDescription' => null,
        'overridenPaymentDescription' => null,
        'workingDays' => 'double',
        'workingDaysOverride' => 'double',
        'totalDays' => 'double',
        'totalDaysOverride' => 'double',
        'useAssumedPensionablePay' => null,
        'assumedPensionablePays' => null,
        'offsetPay' => null,
        'sspPayFromDayOne' => null,
        'linkedPiw' => null,
        'kitSplitDays' => 'date-time',
        'historicSspRequiresProcessing' => null,
        'historicSxpRequiresProcessing' => null,
        'openingPay' => 'double',
        'useOpeningPay' => null,
        'historicOspRequiresProcessing' => null,
        'historicOmpRequiresProcessing' => null,
        'historicSmpRequiresProcessing' => null,
        'occupationalMaternityPolicyUniqueId' => 'uuid',
        'openingOmpPay' => 'double',
        'payRunExistsWithOccMaternityPay' => null,
        'calculationType' => null,
        'strikeHoursToDeduct' => 'double',
        'customPayments' => null,
        'customProRataRules' => null,
        'lastProcessedFrom' => 'date',
        'isReversed' => null,
        'paymentTier' => null,
        'documentCount' => 'int32',
        'documents' => null,
        'employee' => null,
        'id' => 'uuid'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'providerId' => false,
        'externalId' => true,
        'type' => false,
        'pay' => false,
        'payFrequency' => false,
        'payRunExistsWithStatPay' => false,
        'from' => false,
        'to' => false,
        'notes' => true,
        'averageWeeklyEarnings' => false,
        'automaticAWECalculation' => false,
        'babyDate' => true,
        'secondaryBabyDate' => true,
        'tertiaryBabyDate' => true,
        'overridePaymentDescription' => false,
        'overridenPaymentDescription' => true,
        'workingDays' => false,
        'workingDaysOverride' => true,
        'totalDays' => false,
        'totalDaysOverride' => true,
        'useAssumedPensionablePay' => false,
        'assumedPensionablePays' => true,
        'offsetPay' => false,
        'sspPayFromDayOne' => false,
        'linkedPiw' => false,
        'kitSplitDays' => true,
        'historicSspRequiresProcessing' => false,
        'historicSxpRequiresProcessing' => false,
        'openingPay' => true,
        'useOpeningPay' => false,
        'historicOspRequiresProcessing' => false,
        'historicOmpRequiresProcessing' => false,
        'historicSmpRequiresProcessing' => false,
        'occupationalMaternityPolicyUniqueId' => true,
        'openingOmpPay' => true,
        'payRunExistsWithOccMaternityPay' => false,
        'calculationType' => false,
        'strikeHoursToDeduct' => true,
        'customPayments' => true,
        'customProRataRules' => true,
        'lastProcessedFrom' => true,
        'isReversed' => false,
        'paymentTier' => false,
        'documentCount' => false,
        'documents' => true,
        'employee' => false,
        'id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'providerId' => 'providerId',
        'externalId' => 'externalId',
        'type' => 'type',
        'pay' => 'pay',
        'payFrequency' => 'payFrequency',
        'payRunExistsWithStatPay' => 'payRunExistsWithStatPay',
        'from' => 'from',
        'to' => 'to',
        'notes' => 'notes',
        'averageWeeklyEarnings' => 'averageWeeklyEarnings',
        'automaticAWECalculation' => 'automaticAWECalculation',
        'babyDate' => 'babyDate',
        'secondaryBabyDate' => 'secondaryBabyDate',
        'tertiaryBabyDate' => 'tertiaryBabyDate',
        'overridePaymentDescription' => 'overridePaymentDescription',
        'overridenPaymentDescription' => 'overridenPaymentDescription',
        'workingDays' => 'workingDays',
        'workingDaysOverride' => 'workingDaysOverride',
        'totalDays' => 'totalDays',
        'totalDaysOverride' => 'totalDaysOverride',
        'useAssumedPensionablePay' => 'useAssumedPensionablePay',
        'assumedPensionablePays' => 'assumedPensionablePays',
        'offsetPay' => 'offsetPay',
        'sspPayFromDayOne' => 'sspPayFromDayOne',
        'linkedPiw' => 'linkedPiw',
        'kitSplitDays' => 'kitSplitDays',
        'historicSspRequiresProcessing' => 'historicSspRequiresProcessing',
        'historicSxpRequiresProcessing' => 'historicSxpRequiresProcessing',
        'openingPay' => 'openingPay',
        'useOpeningPay' => 'useOpeningPay',
        'historicOspRequiresProcessing' => 'historicOspRequiresProcessing',
        'historicOmpRequiresProcessing' => 'historicOmpRequiresProcessing',
        'historicSmpRequiresProcessing' => 'historicSmpRequiresProcessing',
        'occupationalMaternityPolicyUniqueId' => 'occupationalMaternityPolicyUniqueId',
        'openingOmpPay' => 'openingOmpPay',
        'payRunExistsWithOccMaternityPay' => 'payRunExistsWithOccMaternityPay',
        'calculationType' => 'calculationType',
        'strikeHoursToDeduct' => 'strikeHoursToDeduct',
        'customPayments' => 'customPayments',
        'customProRataRules' => 'customProRataRules',
        'lastProcessedFrom' => 'lastProcessedFrom',
        'isReversed' => 'isReversed',
        'paymentTier' => 'paymentTier',
        'documentCount' => 'documentCount',
        'documents' => 'documents',
        'employee' => 'employee',
        'id' => 'id'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'providerId' => 'setProviderId',
        'externalId' => 'setExternalId',
        'type' => 'setType',
        'pay' => 'setPay',
        'payFrequency' => 'setPayFrequency',
        'payRunExistsWithStatPay' => 'setPayRunExistsWithStatPay',
        'from' => 'setFrom',
        'to' => 'setTo',
        'notes' => 'setNotes',
        'averageWeeklyEarnings' => 'setAverageWeeklyEarnings',
        'automaticAWECalculation' => 'setAutomaticAWECalculation',
        'babyDate' => 'setBabyDate',
        'secondaryBabyDate' => 'setSecondaryBabyDate',
        'tertiaryBabyDate' => 'setTertiaryBabyDate',
        'overridePaymentDescription' => 'setOverridePaymentDescription',
        'overridenPaymentDescription' => 'setOverridenPaymentDescription',
        'workingDays' => 'setWorkingDays',
        'workingDaysOverride' => 'setWorkingDaysOverride',
        'totalDays' => 'setTotalDays',
        'totalDaysOverride' => 'setTotalDaysOverride',
        'useAssumedPensionablePay' => 'setUseAssumedPensionablePay',
        'assumedPensionablePays' => 'setAssumedPensionablePays',
        'offsetPay' => 'setOffsetPay',
        'sspPayFromDayOne' => 'setSspPayFromDayOne',
        'linkedPiw' => 'setLinkedPiw',
        'kitSplitDays' => 'setKitSplitDays',
        'historicSspRequiresProcessing' => 'setHistoricSspRequiresProcessing',
        'historicSxpRequiresProcessing' => 'setHistoricSxpRequiresProcessing',
        'openingPay' => 'setOpeningPay',
        'useOpeningPay' => 'setUseOpeningPay',
        'historicOspRequiresProcessing' => 'setHistoricOspRequiresProcessing',
        'historicOmpRequiresProcessing' => 'setHistoricOmpRequiresProcessing',
        'historicSmpRequiresProcessing' => 'setHistoricSmpRequiresProcessing',
        'occupationalMaternityPolicyUniqueId' => 'setOccupationalMaternityPolicyUniqueId',
        'openingOmpPay' => 'setOpeningOmpPay',
        'payRunExistsWithOccMaternityPay' => 'setPayRunExistsWithOccMaternityPay',
        'calculationType' => 'setCalculationType',
        'strikeHoursToDeduct' => 'setStrikeHoursToDeduct',
        'customPayments' => 'setCustomPayments',
        'customProRataRules' => 'setCustomProRataRules',
        'lastProcessedFrom' => 'setLastProcessedFrom',
        'isReversed' => 'setIsReversed',
        'paymentTier' => 'setPaymentTier',
        'documentCount' => 'setDocumentCount',
        'documents' => 'setDocuments',
        'employee' => 'setEmployee',
        'id' => 'setId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'providerId' => 'getProviderId',
        'externalId' => 'getExternalId',
        'type' => 'getType',
        'pay' => 'getPay',
        'payFrequency' => 'getPayFrequency',
        'payRunExistsWithStatPay' => 'getPayRunExistsWithStatPay',
        'from' => 'getFrom',
        'to' => 'getTo',
        'notes' => 'getNotes',
        'averageWeeklyEarnings' => 'getAverageWeeklyEarnings',
        'automaticAWECalculation' => 'getAutomaticAWECalculation',
        'babyDate' => 'getBabyDate',
        'secondaryBabyDate' => 'getSecondaryBabyDate',
        'tertiaryBabyDate' => 'getTertiaryBabyDate',
        'overridePaymentDescription' => 'getOverridePaymentDescription',
        'overridenPaymentDescription' => 'getOverridenPaymentDescription',
        'workingDays' => 'getWorkingDays',
        'workingDaysOverride' => 'getWorkingDaysOverride',
        'totalDays' => 'getTotalDays',
        'totalDaysOverride' => 'getTotalDaysOverride',
        'useAssumedPensionablePay' => 'getUseAssumedPensionablePay',
        'assumedPensionablePays' => 'getAssumedPensionablePays',
        'offsetPay' => 'getOffsetPay',
        'sspPayFromDayOne' => 'getSspPayFromDayOne',
        'linkedPiw' => 'getLinkedPiw',
        'kitSplitDays' => 'getKitSplitDays',
        'historicSspRequiresProcessing' => 'getHistoricSspRequiresProcessing',
        'historicSxpRequiresProcessing' => 'getHistoricSxpRequiresProcessing',
        'openingPay' => 'getOpeningPay',
        'useOpeningPay' => 'getUseOpeningPay',
        'historicOspRequiresProcessing' => 'getHistoricOspRequiresProcessing',
        'historicOmpRequiresProcessing' => 'getHistoricOmpRequiresProcessing',
        'historicSmpRequiresProcessing' => 'getHistoricSmpRequiresProcessing',
        'occupationalMaternityPolicyUniqueId' => 'getOccupationalMaternityPolicyUniqueId',
        'openingOmpPay' => 'getOpeningOmpPay',
        'payRunExistsWithOccMaternityPay' => 'getPayRunExistsWithOccMaternityPay',
        'calculationType' => 'getCalculationType',
        'strikeHoursToDeduct' => 'getStrikeHoursToDeduct',
        'customPayments' => 'getCustomPayments',
        'customProRataRules' => 'getCustomProRataRules',
        'lastProcessedFrom' => 'getLastProcessedFrom',
        'isReversed' => 'getIsReversed',
        'paymentTier' => 'getPaymentTier',
        'documentCount' => 'getDocumentCount',
        'documents' => 'getDocuments',
        'employee' => 'getEmployee',
        'id' => 'getId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('providerId', $data ?? [], null);
        $this->setIfExists('externalId', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('pay', $data ?? [], null);
        $this->setIfExists('payFrequency', $data ?? [], null);
        $this->setIfExists('payRunExistsWithStatPay', $data ?? [], null);
        $this->setIfExists('from', $data ?? [], null);
        $this->setIfExists('to', $data ?? [], null);
        $this->setIfExists('notes', $data ?? [], null);
        $this->setIfExists('averageWeeklyEarnings', $data ?? [], null);
        $this->setIfExists('automaticAWECalculation', $data ?? [], null);
        $this->setIfExists('babyDate', $data ?? [], null);
        $this->setIfExists('secondaryBabyDate', $data ?? [], null);
        $this->setIfExists('tertiaryBabyDate', $data ?? [], null);
        $this->setIfExists('overridePaymentDescription', $data ?? [], null);
        $this->setIfExists('overridenPaymentDescription', $data ?? [], null);
        $this->setIfExists('workingDays', $data ?? [], null);
        $this->setIfExists('workingDaysOverride', $data ?? [], null);
        $this->setIfExists('totalDays', $data ?? [], null);
        $this->setIfExists('totalDaysOverride', $data ?? [], null);
        $this->setIfExists('useAssumedPensionablePay', $data ?? [], null);
        $this->setIfExists('assumedPensionablePays', $data ?? [], null);
        $this->setIfExists('offsetPay', $data ?? [], null);
        $this->setIfExists('sspPayFromDayOne', $data ?? [], null);
        $this->setIfExists('linkedPiw', $data ?? [], null);
        $this->setIfExists('kitSplitDays', $data ?? [], null);
        $this->setIfExists('historicSspRequiresProcessing', $data ?? [], null);
        $this->setIfExists('historicSxpRequiresProcessing', $data ?? [], null);
        $this->setIfExists('openingPay', $data ?? [], null);
        $this->setIfExists('useOpeningPay', $data ?? [], null);
        $this->setIfExists('historicOspRequiresProcessing', $data ?? [], null);
        $this->setIfExists('historicOmpRequiresProcessing', $data ?? [], null);
        $this->setIfExists('historicSmpRequiresProcessing', $data ?? [], null);
        $this->setIfExists('occupationalMaternityPolicyUniqueId', $data ?? [], null);
        $this->setIfExists('openingOmpPay', $data ?? [], null);
        $this->setIfExists('payRunExistsWithOccMaternityPay', $data ?? [], null);
        $this->setIfExists('calculationType', $data ?? [], null);
        $this->setIfExists('strikeHoursToDeduct', $data ?? [], null);
        $this->setIfExists('customPayments', $data ?? [], null);
        $this->setIfExists('customProRataRules', $data ?? [], null);
        $this->setIfExists('lastProcessedFrom', $data ?? [], null);
        $this->setIfExists('isReversed', $data ?? [], null);
        $this->setIfExists('paymentTier', $data ?? [], null);
        $this->setIfExists('documentCount', $data ?? [], null);
        $this->setIfExists('documents', $data ?? [], null);
        $this->setIfExists('employee', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        if (!is_null($this->container['externalId']) && (mb_strlen($this->container['externalId']) > 100)) {
            $invalidProperties[] = "invalid value for 'externalId', the character length must be smaller than or equal to 100.";
        }

        if (!is_null($this->container['notes']) && (mb_strlen($this->container['notes']) > 300)) {
            $invalidProperties[] = "invalid value for 'notes', the character length must be smaller than or equal to 300.";
        }

        if (!is_null($this->container['overridenPaymentDescription']) && (mb_strlen($this->container['overridenPaymentDescription']) > 150)) {
            $invalidProperties[] = "invalid value for 'overridenPaymentDescription', the character length must be smaller than or equal to 150.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets providerId
     *
     * @return \SynergiTech\Staffology\Model\ExternalDataProviderId|null
     */
    public function getProviderId(): ?\SynergiTech\Staffology\Model\ExternalDataProviderId
    {
        return $this->container['providerId'];
    }

    /**
     * Sets providerId
     *
     * @param \SynergiTech\Staffology\Model\ExternalDataProviderId|null $providerId providerId
     *
     * @return $this
     */
    public function setProviderId(?\SynergiTech\Staffology\Model\ExternalDataProviderId $providerId): static
    {
        if (is_null($providerId)) {
            throw new InvalidArgumentException('non-nullable providerId cannot be null');
        }
        $this->container['providerId'] = $providerId;

        return $this;
    }

    /**
     * Gets externalId
     *
     * @return string|null
     */
    public function getExternalId(): ?string
    {
        return $this->container['externalId'];
    }

    /**
     * Sets externalId
     *
     * @param string|null $externalId If the Leave comes from an ExternalDataProvider, then this is its Id in the ExternalDataProvider
     *
     * @return $this
     */
    public function setExternalId(?string $externalId): static
    {
        if (is_null($externalId)) {
            array_push($this->openAPINullablesSetToNull, 'externalId');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('externalId', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($externalId) && (mb_strlen($externalId) > 100)) {
            throw new InvalidArgumentException('invalid length for $externalId when calling Leave., must be smaller than or equal to 100.');
        }

        $this->container['externalId'] = $externalId;

        return $this;
    }

    /**
     * Gets type
     *
     * @return \SynergiTech\Staffology\Model\LeaveType|null
     */
    public function getType(): ?\SynergiTech\Staffology\Model\LeaveType
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param \SynergiTech\Staffology\Model\LeaveType|null $type type
     *
     * @return $this
     */
    public function setType(?\SynergiTech\Staffology\Model\LeaveType $type): static
    {
        if (is_null($type)) {
            throw new InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets pay
     *
     * @return \SynergiTech\Staffology\Model\LeavePayType|null
     */
    public function getPay(): ?\SynergiTech\Staffology\Model\LeavePayType
    {
        return $this->container['pay'];
    }

    /**
     * Sets pay
     *
     * @param \SynergiTech\Staffology\Model\LeavePayType|null $pay pay
     *
     * @return $this
     */
    public function setPay(?\SynergiTech\Staffology\Model\LeavePayType $pay): static
    {
        if (is_null($pay)) {
            throw new InvalidArgumentException('non-nullable pay cannot be null');
        }
        $this->container['pay'] = $pay;

        return $this;
    }

    /**
     * Gets payFrequency
     *
     * @return \SynergiTech\Staffology\Model\StatPayFrequency|null
     */
    public function getPayFrequency(): ?\SynergiTech\Staffology\Model\StatPayFrequency
    {
        return $this->container['payFrequency'];
    }

    /**
     * Sets payFrequency
     *
     * @param \SynergiTech\Staffology\Model\StatPayFrequency|null $payFrequency payFrequency
     *
     * @return $this
     */
    public function setPayFrequency(?\SynergiTech\Staffology\Model\StatPayFrequency $payFrequency): static
    {
        if (is_null($payFrequency)) {
            throw new InvalidArgumentException('non-nullable payFrequency cannot be null');
        }
        $this->container['payFrequency'] = $payFrequency;

        return $this;
    }

    /**
     * Gets payRunExistsWithStatPay
     *
     * @return bool|null
     */
    public function getPayRunExistsWithStatPay(): ?bool
    {
        return $this->container['payRunExistsWithStatPay'];
    }

    /**
     * Sets payRunExistsWithStatPay
     *
     * @param bool|null $payRunExistsWithStatPay payRunExistsWithStatPay
     *
     * @return $this
     */
    public function setPayRunExistsWithStatPay(?bool $payRunExistsWithStatPay): static
    {
        if (is_null($payRunExistsWithStatPay)) {
            throw new InvalidArgumentException('non-nullable payRunExistsWithStatPay cannot be null');
        }
        $this->container['payRunExistsWithStatPay'] = $payRunExistsWithStatPay;

        return $this;
    }

    /**
     * Gets from
     *
     * @return \DateTime|null
     */
    public function getFrom(): ?\DateTime
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param \DateTime|null $from The first day of Leave.  If it's a half day PM then set the time portion to 12:00:00, otherwise leave it blank or set it to 00:00:00
     *
     * @return $this
     */
    public function setFrom(?\DateTime $from): static
    {
        if (is_null($from)) {
            throw new InvalidArgumentException('non-nullable from cannot be null');
        }
        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets to
     *
     * @return \DateTime|null
     */
    public function getTo(): ?\DateTime
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param \DateTime|null $to The last day of Leave.  If it's a half day AM then set the time portion to 11:59:59, otherwise set it to 23:59:59
     *
     * @return $this
     */
    public function setTo(?\DateTime $to): static
    {
        if (is_null($to)) {
            throw new InvalidArgumentException('non-nullable to cannot be null');
        }
        $this->container['to'] = $to;

        return $this;
    }

    /**
     * Gets notes
     *
     * @return string|null
     */
    public function getNotes(): ?string
    {
        return $this->container['notes'];
    }

    /**
     * Sets notes
     *
     * @param string|null $notes A free-form text field to record any comments
     *
     * @return $this
     */
    public function setNotes(?string $notes): static
    {
        if (is_null($notes)) {
            array_push($this->openAPINullablesSetToNull, 'notes');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('notes', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($notes) && (mb_strlen($notes) > 300)) {
            throw new InvalidArgumentException('invalid length for $notes when calling Leave., must be smaller than or equal to 300.');
        }

        $this->container['notes'] = $notes;

        return $this;
    }

    /**
     * Gets averageWeeklyEarnings
     *
     * @return float|null
     */
    public function getAverageWeeklyEarnings(): ?float
    {
        return $this->container['averageWeeklyEarnings'];
    }

    /**
     * Sets averageWeeklyEarnings
     *
     * @param float|null $averageWeeklyEarnings The employees average weekly earnings. Only relevant for Statutory Pay  It's advised that you don't try to calculate this yourself.
     *
     * @return $this
     */
    public function setAverageWeeklyEarnings(?float $averageWeeklyEarnings): static
    {
        if (is_null($averageWeeklyEarnings)) {
            throw new InvalidArgumentException('non-nullable averageWeeklyEarnings cannot be null');
        }
        $this->container['averageWeeklyEarnings'] = $averageWeeklyEarnings;

        return $this;
    }

    /**
     * Gets automaticAWECalculation
     *
     * @return bool|null
     */
    public function getAutomaticAWECalculation(): ?bool
    {
        return $this->container['automaticAWECalculation'];
    }

    /**
     * Sets automaticAWECalculation
     *
     * @param bool|null $automaticAWECalculation If set to True then we'll automatically calculate the AverageWeeklyEarnings.   Set it to false if you want to manually provide a figure that overrides our calculations
     *
     * @return $this
     */
    public function setAutomaticAWECalculation(?bool $automaticAWECalculation): static
    {
        if (is_null($automaticAWECalculation)) {
            throw new InvalidArgumentException('non-nullable automaticAWECalculation cannot be null');
        }
        $this->container['automaticAWECalculation'] = $automaticAWECalculation;

        return $this;
    }

    /**
     * Gets babyDate
     *
     * @return \DateTime|null
     */
    public function getBabyDate(): ?\DateTime
    {
        return $this->container['babyDate'];
    }

    /**
     * Sets babyDate
     *
     * @param \DateTime|null $babyDate Only required for Parental Leave with Statutory Pay  If Type is Maternity or Paternity then this is the date the baby is due.  For Adoption this is the Matching Date.  For Neonatal Care is the Baby Due / Matching / Placement Date
     *
     * @return $this
     */
    public function setBabyDate(?\DateTime $babyDate): static
    {
        if (is_null($babyDate)) {
            array_push($this->openAPINullablesSetToNull, 'babyDate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('babyDate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['babyDate'] = $babyDate;

        return $this;
    }

    /**
     * Gets secondaryBabyDate
     *
     * @return \DateTime|null
     */
    public function getSecondaryBabyDate(): ?\DateTime
    {
        return $this->container['secondaryBabyDate'];
    }

    /**
     * Sets secondaryBabyDate
     *
     * @param \DateTime|null $secondaryBabyDate Only used for Parental Leave with Statutory Pay  If Type is Maternity, Paternity, SharedParental (Birth) then this is the the Baby Born Date.  For Adoption or SharedParental (Adoption) this is the Expected Placement Date.
     *
     * @return $this
     */
    public function setSecondaryBabyDate(?\DateTime $secondaryBabyDate): static
    {
        if (is_null($secondaryBabyDate)) {
            array_push($this->openAPINullablesSetToNull, 'secondaryBabyDate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('secondaryBabyDate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['secondaryBabyDate'] = $secondaryBabyDate;

        return $this;
    }

    /**
     * Gets tertiaryBabyDate
     *
     * @return \DateTime|null
     */
    public function getTertiaryBabyDate(): ?\DateTime
    {
        return $this->container['tertiaryBabyDate'];
    }

    /**
     * Sets tertiaryBabyDate
     *
     * @param \DateTime|null $tertiaryBabyDate Only used for Parental Leave with Statutory Pay  If Type is Adoption this is the Placement Date.  If Type is Neonatal Care is the Date Baby Entered Neonatal Care
     *
     * @return $this
     */
    public function setTertiaryBabyDate(?\DateTime $tertiaryBabyDate): static
    {
        if (is_null($tertiaryBabyDate)) {
            array_push($this->openAPINullablesSetToNull, 'tertiaryBabyDate');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tertiaryBabyDate', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tertiaryBabyDate'] = $tertiaryBabyDate;

        return $this;
    }

    /**
     * Gets overridePaymentDescription
     *
     * @return bool|null
     */
    public function getOverridePaymentDescription(): ?bool
    {
        return $this->container['overridePaymentDescription'];
    }

    /**
     * Sets overridePaymentDescription
     *
     * @param bool|null $overridePaymentDescription If Pay is StatutoryPay and you want to override our description that goes with the payment then set this to true
     *
     * @return $this
     */
    public function setOverridePaymentDescription(?bool $overridePaymentDescription): static
    {
        if (is_null($overridePaymentDescription)) {
            throw new InvalidArgumentException('non-nullable overridePaymentDescription cannot be null');
        }
        $this->container['overridePaymentDescription'] = $overridePaymentDescription;

        return $this;
    }

    /**
     * Gets overridenPaymentDescription
     *
     * @return string|null
     */
    public function getOverridenPaymentDescription(): ?string
    {
        return $this->container['overridenPaymentDescription'];
    }

    /**
     * Sets overridenPaymentDescription
     *
     * @param string|null $overridenPaymentDescription If OverridePaymentDescription is true and Pay is set to StatutoryPay then we'll use this as the description for the payment amount.
     *
     * @return $this
     */
    public function setOverridenPaymentDescription(?string $overridenPaymentDescription): static
    {
        if (is_null($overridenPaymentDescription)) {
            array_push($this->openAPINullablesSetToNull, 'overridenPaymentDescription');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('overridenPaymentDescription', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($overridenPaymentDescription) && (mb_strlen($overridenPaymentDescription) > 150)) {
            throw new InvalidArgumentException('invalid length for $overridenPaymentDescription when calling Leave., must be smaller than or equal to 150.');
        }

        $this->container['overridenPaymentDescription'] = $overridenPaymentDescription;

        return $this;
    }

    /**
     * Gets workingDays
     *
     * @return float|null
     */
    public function getWorkingDays(): ?float
    {
        return $this->container['workingDays'];
    }

    /**
     * Sets workingDays
     *
     * @param float|null $workingDays [readonly] The number of working days covered by this leave.  This is calculated based on the employees Working Pattern.
     *
     * @return $this
     */
    public function setWorkingDays(?float $workingDays): static
    {
        if (is_null($workingDays)) {
            throw new InvalidArgumentException('non-nullable workingDays cannot be null');
        }
        $this->container['workingDays'] = $workingDays;

        return $this;
    }

    /**
     * Gets workingDaysOverride
     *
     * @return float|null
     */
    public function getWorkingDaysOverride(): ?float
    {
        return $this->container['workingDaysOverride'];
    }

    /**
     * Sets workingDaysOverride
     *
     * @param float|null $workingDaysOverride If a value is provided here then this will be used in place of the calculated WorkingDays value
     *
     * @return $this
     */
    public function setWorkingDaysOverride(?float $workingDaysOverride): static
    {
        if (is_null($workingDaysOverride)) {
            array_push($this->openAPINullablesSetToNull, 'workingDaysOverride');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('workingDaysOverride', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['workingDaysOverride'] = $workingDaysOverride;

        return $this;
    }

    /**
     * Gets totalDays
     *
     * @return float|null
     */
    public function getTotalDays(): ?float
    {
        return $this->container['totalDays'];
    }

    /**
     * Sets totalDays
     *
     * @param float|null $totalDays [readonly] The number of days covered by this leave, regardless of whether or not they're working days.  This is calculated based on the employees Working Pattern.
     *
     * @return $this
     */
    public function setTotalDays(?float $totalDays): static
    {
        if (is_null($totalDays)) {
            throw new InvalidArgumentException('non-nullable totalDays cannot be null');
        }
        $this->container['totalDays'] = $totalDays;

        return $this;
    }

    /**
     * Gets totalDaysOverride
     *
     * @return float|null
     */
    public function getTotalDaysOverride(): ?float
    {
        return $this->container['totalDaysOverride'];
    }

    /**
     * Sets totalDaysOverride
     *
     * @param float|null $totalDaysOverride If a value is provided here then this will be used in place of the calculated TotalDays value
     *
     * @return $this
     */
    public function setTotalDaysOverride(?float $totalDaysOverride): static
    {
        if (is_null($totalDaysOverride)) {
            array_push($this->openAPINullablesSetToNull, 'totalDaysOverride');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('totalDaysOverride', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['totalDaysOverride'] = $totalDaysOverride;

        return $this;
    }

    /**
     * Gets useAssumedPensionablePay
     *
     * @return bool|null
     */
    public function getUseAssumedPensionablePay(): ?bool
    {
        return $this->container['useAssumedPensionablePay'];
    }

    /**
     * Sets useAssumedPensionablePay
     *
     * @param bool|null $useAssumedPensionablePay If this Leave has Statutory Pay then if this is set to True  we will use the value set in AssumedPensionablePay to work out the employer pension contributions
     *
     * @return $this
     */
    public function setUseAssumedPensionablePay(?bool $useAssumedPensionablePay): static
    {
        if (is_null($useAssumedPensionablePay)) {
            throw new InvalidArgumentException('non-nullable useAssumedPensionablePay cannot be null');
        }
        $this->container['useAssumedPensionablePay'] = $useAssumedPensionablePay;

        return $this;
    }

    /**
     * Gets assumedPensionablePays
     *
     * @return \SynergiTech\Staffology\Model\LeaveAssumedPensionablePay[]|null
     */
    public function getAssumedPensionablePays(): ?array
    {
        return $this->container['assumedPensionablePays'];
    }

    /**
     * Sets assumedPensionablePays
     *
     * @param \SynergiTech\Staffology\Model\LeaveAssumedPensionablePay[]|null $assumedPensionablePays if UseAssumedPensionablePay is True, then this is the value used to calculate the employer pension contributions
     *
     * @return $this
     */
    public function setAssumedPensionablePays(?array $assumedPensionablePays): static
    {
        if (is_null($assumedPensionablePays)) {
            array_push($this->openAPINullablesSetToNull, 'assumedPensionablePays');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('assumedPensionablePays', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['assumedPensionablePays'] = $assumedPensionablePays;

        return $this;
    }

    /**
     * Gets offsetPay
     *
     * @return bool|null
     */
    public function getOffsetPay(): ?bool
    {
        return $this->container['offsetPay'];
    }

    /**
     * Sets offsetPay
     *
     * @param bool|null $offsetPay If this Leave has Statutory Pay  and this is set to True and the employe eis paid a fixed amoutn per period  with Leave Adjustments set to automatic, then we'll reduce their pay for the period by the statutory amount  so the employee still gets paid the full amount.
     *
     * @return $this
     */
    public function setOffsetPay(?bool $offsetPay): static
    {
        if (is_null($offsetPay)) {
            throw new InvalidArgumentException('non-nullable offsetPay cannot be null');
        }
        $this->container['offsetPay'] = $offsetPay;

        return $this;
    }

    /**
     * Gets sspPayFromDayOne
     *
     * @return bool|null
     */
    public function getSspPayFromDayOne(): ?bool
    {
        return $this->container['sspPayFromDayOne'];
    }

    /**
     * Sets sspPayFromDayOne
     *
     * @param bool|null $sspPayFromDayOne If this is Sick Leave with Statutory Pay then setting this to true  will force SSP to be paid from day one rather than the usual rule   of the first Working Day after 3 Qualifying Days
     *
     * @return $this
     */
    public function setSspPayFromDayOne(?bool $sspPayFromDayOne): static
    {
        if (is_null($sspPayFromDayOne)) {
            throw new InvalidArgumentException('non-nullable sspPayFromDayOne cannot be null');
        }
        $this->container['sspPayFromDayOne'] = $sspPayFromDayOne;

        return $this;
    }

    /**
     * Gets linkedPiw
     *
     * @return \SynergiTech\Staffology\Model\LinkedPiw|null
     */
    public function getLinkedPiw(): ?\SynergiTech\Staffology\Model\LinkedPiw
    {
        return $this->container['linkedPiw'];
    }

    /**
     * Sets linkedPiw
     *
     * @param \SynergiTech\Staffology\Model\LinkedPiw|null $linkedPiw linkedPiw
     *
     * @return $this
     */
    public function setLinkedPiw(?\SynergiTech\Staffology\Model\LinkedPiw $linkedPiw): static
    {
        if (is_null($linkedPiw)) {
            throw new InvalidArgumentException('non-nullable linkedPiw cannot be null');
        }
        $this->container['linkedPiw'] = $linkedPiw;

        return $this;
    }

    /**
     * Gets kitSplitDays
     *
     * @return \DateTime[]|null
     */
    public function getKitSplitDays(): ?array
    {
        return $this->container['kitSplitDays'];
    }

    /**
     * Sets kitSplitDays
     *
     * @param \DateTime[]|null $kitSplitDays If the LeaveType supports KIT/SPLIT days then use this property to store the list of dates
     *
     * @return $this
     */
    public function setKitSplitDays(?array $kitSplitDays): static
    {
        if (is_null($kitSplitDays)) {
            array_push($this->openAPINullablesSetToNull, 'kitSplitDays');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('kitSplitDays', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['kitSplitDays'] = $kitSplitDays;

        return $this;
    }

    /**
     * Gets historicSspRequiresProcessing
     *
     * @return bool|null
     */
    public function getHistoricSspRequiresProcessing(): ?bool
    {
        return $this->container['historicSspRequiresProcessing'];
    }

    /**
     * Sets historicSspRequiresProcessing
     *
     * @param bool|null $historicSspRequiresProcessing Only used during the creation of historical SSP.  When creating historical SSP, this will determine whether to pay that leave in the next PayRun.
     *
     * @return $this
     */
    public function setHistoricSspRequiresProcessing(?bool $historicSspRequiresProcessing): static
    {
        if (is_null($historicSspRequiresProcessing)) {
            throw new InvalidArgumentException('non-nullable historicSspRequiresProcessing cannot be null');
        }
        $this->container['historicSspRequiresProcessing'] = $historicSspRequiresProcessing;

        return $this;
    }

    /**
     * Gets historicSxpRequiresProcessing
     *
     * @return bool|null
     */
    public function getHistoricSxpRequiresProcessing(): ?bool
    {
        return $this->container['historicSxpRequiresProcessing'];
    }

    /**
     * Sets historicSxpRequiresProcessing
     *
     * @param bool|null $historicSxpRequiresProcessing Used during to determine whether to back pay before current payrun
     *
     * @return $this
     */
    public function setHistoricSxpRequiresProcessing(?bool $historicSxpRequiresProcessing): static
    {
        if (is_null($historicSxpRequiresProcessing)) {
            throw new InvalidArgumentException('non-nullable historicSxpRequiresProcessing cannot be null');
        }
        $this->container['historicSxpRequiresProcessing'] = $historicSxpRequiresProcessing;

        return $this;
    }

    /**
     * Gets openingPay
     *
     * @return float|null
     */
    public function getOpeningPay(): ?float
    {
        return $this->container['openingPay'];
    }

    /**
     * Sets openingPay
     *
     * @param float|null $openingPay Opening pay which has already been paid to the employee in another system
     *
     * @return $this
     */
    public function setOpeningPay(?float $openingPay): static
    {
        if (is_null($openingPay)) {
            array_push($this->openAPINullablesSetToNull, 'openingPay');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('openingPay', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['openingPay'] = $openingPay;

        return $this;
    }

    /**
     * Gets useOpeningPay
     *
     * @return bool|null
     */
    public function getUseOpeningPay(): ?bool
    {
        return $this->container['useOpeningPay'];
    }

    /**
     * Sets useOpeningPay
     *
     * @param bool|null $useOpeningPay Use the OpeningPay which has already been paid in another system
     *
     * @return $this
     */
    public function setUseOpeningPay(?bool $useOpeningPay): static
    {
        if (is_null($useOpeningPay)) {
            throw new InvalidArgumentException('non-nullable useOpeningPay cannot be null');
        }
        $this->container['useOpeningPay'] = $useOpeningPay;

        return $this;
    }

    /**
     * Gets historicOspRequiresProcessing
     *
     * @return bool|null
     */
    public function getHistoricOspRequiresProcessing(): ?bool
    {
        return $this->container['historicOspRequiresProcessing'];
    }

    /**
     * Sets historicOspRequiresProcessing
     *
     * @param bool|null $historicOspRequiresProcessing Only used during the creation of sickness Occupational Policy.  When creating historical SOP, this will determine whether to pay that leave in the next PayRun.
     *
     * @return $this
     */
    public function setHistoricOspRequiresProcessing(?bool $historicOspRequiresProcessing): static
    {
        if (is_null($historicOspRequiresProcessing)) {
            throw new InvalidArgumentException('non-nullable historicOspRequiresProcessing cannot be null');
        }
        $this->container['historicOspRequiresProcessing'] = $historicOspRequiresProcessing;

        return $this;
    }

    /**
     * Gets historicOmpRequiresProcessing
     *
     * @return bool|null
     */
    public function getHistoricOmpRequiresProcessing(): ?bool
    {
        return $this->container['historicOmpRequiresProcessing'];
    }

    /**
     * Sets historicOmpRequiresProcessing
     *
     * @param bool|null $historicOmpRequiresProcessing Only used during the creation and update of occupational maternity leaves.  When creating or updating historical occupational leaves, this will determine whether to pay the historic payments or correction in the next PayRun.
     *
     * @return $this
     */
    public function setHistoricOmpRequiresProcessing(?bool $historicOmpRequiresProcessing): static
    {
        if (is_null($historicOmpRequiresProcessing)) {
            throw new InvalidArgumentException('non-nullable historicOmpRequiresProcessing cannot be null');
        }
        $this->container['historicOmpRequiresProcessing'] = $historicOmpRequiresProcessing;

        return $this;
    }

    /**
     * Gets historicSmpRequiresProcessing
     *
     * @return bool|null
     */
    public function getHistoricSmpRequiresProcessing(): ?bool
    {
        return $this->container['historicSmpRequiresProcessing'];
    }

    /**
     * Sets historicSmpRequiresProcessing
     *
     * @param bool|null $historicSmpRequiresProcessing Only used during the creation and update of statutory maternity leaves.  When creating or updating historical statutory maternity leaves, this will determine whether to pay the historic payments or correction in the next PayRun.
     *
     * @return $this
     */
    public function setHistoricSmpRequiresProcessing(?bool $historicSmpRequiresProcessing): static
    {
        if (is_null($historicSmpRequiresProcessing)) {
            throw new InvalidArgumentException('non-nullable historicSmpRequiresProcessing cannot be null');
        }
        $this->container['historicSmpRequiresProcessing'] = $historicSmpRequiresProcessing;

        return $this;
    }

    /**
     * Gets occupationalMaternityPolicyUniqueId
     *
     * @return string|null
     */
    public function getOccupationalMaternityPolicyUniqueId(): ?string
    {
        return $this->container['occupationalMaternityPolicyUniqueId'];
    }

    /**
     * Sets occupationalMaternityPolicyUniqueId
     *
     * @param string|null $occupationalMaternityPolicyUniqueId Occupational Maternity Policy Id when leave type is Maternity and payment type is occupational policy
     *
     * @return $this
     */
    public function setOccupationalMaternityPolicyUniqueId(?string $occupationalMaternityPolicyUniqueId): static
    {
        if (is_null($occupationalMaternityPolicyUniqueId)) {
            array_push($this->openAPINullablesSetToNull, 'occupationalMaternityPolicyUniqueId');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('occupationalMaternityPolicyUniqueId', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['occupationalMaternityPolicyUniqueId'] = $occupationalMaternityPolicyUniqueId;

        return $this;
    }

    /**
     * Gets openingOmpPay
     *
     * @return float|null
     */
    public function getOpeningOmpPay(): ?float
    {
        return $this->container['openingOmpPay'];
    }

    /**
     * Sets openingOmpPay
     *
     * @param float|null $openingOmpPay Opening occupational pay which has already been paid to the employee
     *
     * @return $this
     */
    public function setOpeningOmpPay(?float $openingOmpPay): static
    {
        if (is_null($openingOmpPay)) {
            array_push($this->openAPINullablesSetToNull, 'openingOmpPay');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('openingOmpPay', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['openingOmpPay'] = $openingOmpPay;

        return $this;
    }

    /**
     * Gets payRunExistsWithOccMaternityPay
     *
     * @return bool|null
     */
    public function getPayRunExistsWithOccMaternityPay(): ?bool
    {
        return $this->container['payRunExistsWithOccMaternityPay'];
    }

    /**
     * Sets payRunExistsWithOccMaternityPay
     *
     * @param bool|null $payRunExistsWithOccMaternityPay Indicates whether there is occupational maternity payment associated with a leave in the current pay run.
     *
     * @return $this
     */
    public function setPayRunExistsWithOccMaternityPay(?bool $payRunExistsWithOccMaternityPay): static
    {
        if (is_null($payRunExistsWithOccMaternityPay)) {
            throw new InvalidArgumentException('non-nullable payRunExistsWithOccMaternityPay cannot be null');
        }
        $this->container['payRunExistsWithOccMaternityPay'] = $payRunExistsWithOccMaternityPay;

        return $this;
    }

    /**
     * Gets calculationType
     *
     * @return \SynergiTech\Staffology\Model\LeaveCalculationType|null
     */
    public function getCalculationType(): ?\SynergiTech\Staffology\Model\LeaveCalculationType
    {
        return $this->container['calculationType'];
    }

    /**
     * Sets calculationType
     *
     * @param \SynergiTech\Staffology\Model\LeaveCalculationType|null $calculationType calculationType
     *
     * @return $this
     */
    public function setCalculationType(?\SynergiTech\Staffology\Model\LeaveCalculationType $calculationType): static
    {
        if (is_null($calculationType)) {
            throw new InvalidArgumentException('non-nullable calculationType cannot be null');
        }
        $this->container['calculationType'] = $calculationType;

        return $this;
    }

    /**
     * Gets strikeHoursToDeduct
     *
     * @return float|null
     */
    public function getStrikeHoursToDeduct(): ?float
    {
        return $this->container['strikeHoursToDeduct'];
    }

    /**
     * Sets strikeHoursToDeduct
     *
     * @param float|null $strikeHoursToDeduct The number of hours to be deducted at the employee's contractual rate  This property is valid for strike deducted hours
     *
     * @return $this
     */
    public function setStrikeHoursToDeduct(?float $strikeHoursToDeduct): static
    {
        if (is_null($strikeHoursToDeduct)) {
            array_push($this->openAPINullablesSetToNull, 'strikeHoursToDeduct');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('strikeHoursToDeduct', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['strikeHoursToDeduct'] = $strikeHoursToDeduct;

        return $this;
    }

    /**
     * Gets customPayments
     *
     * @return \SynergiTech\Staffology\Model\LeaveCustomPayment[]|null
     */
    public function getCustomPayments(): ?array
    {
        return $this->container['customPayments'];
    }

    /**
     * Sets customPayments
     *
     * @param \SynergiTech\Staffology\Model\LeaveCustomPayment[]|null $customPayments If this is Sick Leave with Custom Payment, then this stores the RoleId, PercentOfPay and PaySSPInAddition for each  role assigned to an employee that did not end before the start date of the absence.
     *
     * @return $this
     */
    public function setCustomPayments(?array $customPayments): static
    {
        if (is_null($customPayments)) {
            array_push($this->openAPINullablesSetToNull, 'customPayments');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('customPayments', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['customPayments'] = $customPayments;

        return $this;
    }

    /**
     * Gets customProRataRules
     *
     * @return \SynergiTech\Staffology\Model\LeaveCustomProRataRule[]|null
     */
    public function getCustomProRataRules(): ?array
    {
        return $this->container['customProRataRules'];
    }

    /**
     * Sets customProRataRules
     *
     * @param \SynergiTech\Staffology\Model\LeaveCustomProRataRule[]|null $customProRataRules If this is a Leave that supports changing the pro rata at leave level,  This stores the RoleId and ProRataMethod for each  role assigned to an employee that did not end before the start date of the absence.
     *
     * @return $this
     */
    public function setCustomProRataRules(?array $customProRataRules): static
    {
        if (is_null($customProRataRules)) {
            array_push($this->openAPINullablesSetToNull, 'customProRataRules');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('customProRataRules', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['customProRataRules'] = $customProRataRules;

        return $this;
    }

    /**
     * Gets lastProcessedFrom
     *
     * @return \DateTime|null
     */
    public function getLastProcessedFrom(): ?\DateTime
    {
        return $this->container['lastProcessedFrom'];
    }

    /**
     * Sets lastProcessedFrom
     *
     * @param \DateTime|null $lastProcessedFrom [readonly] Last Processed From Date  If this Leave has already been processed,  this will be the original leave from date
     *
     * @return $this
     */
    public function setLastProcessedFrom(?\DateTime $lastProcessedFrom): static
    {
        if (is_null($lastProcessedFrom)) {
            array_push($this->openAPINullablesSetToNull, 'lastProcessedFrom');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('lastProcessedFrom', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['lastProcessedFrom'] = $lastProcessedFrom;

        return $this;
    }

    /**
     * Gets isReversed
     *
     * @return bool|null
     */
    public function getIsReversed(): ?bool
    {
        return $this->container['isReversed'];
    }

    /**
     * Sets isReversed
     *
     * @param bool|null $isReversed If the reversal of this Leave has already been processed,  this will be set to true
     *
     * @return $this
     */
    public function setIsReversed(?bool $isReversed): static
    {
        if (is_null($isReversed)) {
            throw new InvalidArgumentException('non-nullable isReversed cannot be null');
        }
        $this->container['isReversed'] = $isReversed;

        return $this;
    }

    /**
     * Gets paymentTier
     *
     * @return \SynergiTech\Staffology\Model\NeonatalCarePaymentTier|null
     */
    public function getPaymentTier(): ?\SynergiTech\Staffology\Model\NeonatalCarePaymentTier
    {
        return $this->container['paymentTier'];
    }

    /**
     * Sets paymentTier
     *
     * @param \SynergiTech\Staffology\Model\NeonatalCarePaymentTier|null $paymentTier paymentTier
     *
     * @return $this
     */
    public function setPaymentTier(?\SynergiTech\Staffology\Model\NeonatalCarePaymentTier $paymentTier): static
    {
        if (is_null($paymentTier)) {
            throw new InvalidArgumentException('non-nullable paymentTier cannot be null');
        }
        $this->container['paymentTier'] = $paymentTier;

        return $this;
    }

    /**
     * Gets documentCount
     *
     * @return int|null
     */
    public function getDocumentCount(): ?int
    {
        return $this->container['documentCount'];
    }

    /**
     * Sets documentCount
     *
     * @param int|null $documentCount [readonly] The number of attachments associated with this model
     *
     * @return $this
     */
    public function setDocumentCount(?int $documentCount): static
    {
        if (is_null($documentCount)) {
            throw new InvalidArgumentException('non-nullable documentCount cannot be null');
        }
        $this->container['documentCount'] = $documentCount;

        return $this;
    }

    /**
     * Gets documents
     *
     * @return \SynergiTech\Staffology\Model\Item[]|null
     */
    public function getDocuments(): ?array
    {
        return $this->container['documents'];
    }

    /**
     * Sets documents
     *
     * @param \SynergiTech\Staffology\Model\Item[]|null $documents [readonly] The attachments associated with this model
     *
     * @return $this
     */
    public function setDocuments(?array $documents): static
    {
        if (is_null($documents)) {
            array_push($this->openAPINullablesSetToNull, 'documents');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('documents', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['documents'] = $documents;

        return $this;
    }

    /**
     * Gets employee
     *
     * @return \SynergiTech\Staffology\Model\Item|null
     */
    public function getEmployee(): ?\SynergiTech\Staffology\Model\Item
    {
        return $this->container['employee'];
    }

    /**
     * Sets employee
     *
     * @param \SynergiTech\Staffology\Model\Item|null $employee employee
     *
     * @return $this
     */
    public function setEmployee(?\SynergiTech\Staffology\Model\Item $employee): static
    {
        if (is_null($employee)) {
            throw new InvalidArgumentException('non-nullable employee cannot be null');
        }
        $this->container['employee'] = $employee;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId(): ?string
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id [readonly] The unique id of the object
     *
     * @return $this
     */
    public function setId(?string $id): static
    {
        if (is_null($id)) {
            throw new InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


