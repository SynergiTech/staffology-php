<?php
/**
 * PaymentsCsvMapping
 *
 * PHP version 8.1
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Staffology Payroll API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: duane@staffology.co.uk
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Staffology\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use SynergiTech\Staffology\ObjectSerializer;

/**
 * PaymentsCsvMapping Class Doc Comment
 *
 * @description This model is used to save CSV mappings for importing of payments.  It probably has very little practical use outside of our own UI
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class PaymentsCsvMapping implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = 'PaymentsCsvMapping';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'name' => 'string',
        'type' => '\SynergiTech\Staffology\Model\PaymentsCsvMappingType',
        'importBehaviour' => 'int',
        'payBasis' => '\SynergiTech\Staffology\Model\PayBasis',
        'hasHeader' => 'bool',
        'payrollCodeIndex' => 'int',
        'employerIdIndex' => 'int',
        'roleReferenceIndex' => 'int',
        'payAmountIndex' => 'int',
        'payAmountMultiplierIndex' => 'int',
        'noteIndex' => 'int',
        'payCodeIndex' => 'int',
        'hasPaylineCosting' => 'bool',
        'departmentIndex' => 'int',
        'costCentreIndex' => 'int',
        'effectiveFromIndex' => 'int',
        'effectiveToIndex' => 'int',
        'isAutomaticBackPayIndex' => 'int',
        'ignoreInitialBackPayIndex' => 'int',
        'contributesToBasicPayIndex' => 'int',
        'autoAdjustForLeaveIndex' => 'int',
        'analysisCategoryIndexesJson' => 'string',
        'paySpineIndex' => 'int',
        'payGradeIndex' => 'int',
        'spinePointIndex' => 'int',
        'analysisCategoryIndexes' => '\SynergiTech\Staffology\Model\AnalysisCategoryIndex[]',
        'columns' => '\SynergiTech\Staffology\Model\PaymentsCsvMappingColumn[]',
        'id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'name' => null,
        'type' => null,
        'importBehaviour' => 'int32',
        'payBasis' => null,
        'hasHeader' => null,
        'payrollCodeIndex' => 'int32',
        'employerIdIndex' => 'int32',
        'roleReferenceIndex' => 'int32',
        'payAmountIndex' => 'int32',
        'payAmountMultiplierIndex' => 'int32',
        'noteIndex' => 'int32',
        'payCodeIndex' => 'int32',
        'hasPaylineCosting' => null,
        'departmentIndex' => 'int32',
        'costCentreIndex' => 'int32',
        'effectiveFromIndex' => 'int32',
        'effectiveToIndex' => 'int32',
        'isAutomaticBackPayIndex' => 'int32',
        'ignoreInitialBackPayIndex' => 'int32',
        'contributesToBasicPayIndex' => 'int32',
        'autoAdjustForLeaveIndex' => 'int32',
        'analysisCategoryIndexesJson' => null,
        'paySpineIndex' => 'int32',
        'payGradeIndex' => 'int32',
        'spinePointIndex' => 'int32',
        'analysisCategoryIndexes' => null,
        'columns' => null,
        'id' => 'uuid'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'name' => false,
        'type' => false,
        'importBehaviour' => false,
        'payBasis' => false,
        'hasHeader' => false,
        'payrollCodeIndex' => false,
        'employerIdIndex' => false,
        'roleReferenceIndex' => false,
        'payAmountIndex' => false,
        'payAmountMultiplierIndex' => false,
        'noteIndex' => false,
        'payCodeIndex' => false,
        'hasPaylineCosting' => false,
        'departmentIndex' => false,
        'costCentreIndex' => false,
        'effectiveFromIndex' => false,
        'effectiveToIndex' => false,
        'isAutomaticBackPayIndex' => false,
        'ignoreInitialBackPayIndex' => false,
        'contributesToBasicPayIndex' => false,
        'autoAdjustForLeaveIndex' => false,
        'analysisCategoryIndexesJson' => true,
        'paySpineIndex' => false,
        'payGradeIndex' => false,
        'spinePointIndex' => false,
        'analysisCategoryIndexes' => true,
        'columns' => true,
        'id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'name' => 'name',
        'type' => 'type',
        'importBehaviour' => 'importBehaviour',
        'payBasis' => 'payBasis',
        'hasHeader' => 'hasHeader',
        'payrollCodeIndex' => 'payrollCodeIndex',
        'employerIdIndex' => 'employerIdIndex',
        'roleReferenceIndex' => 'roleReferenceIndex',
        'payAmountIndex' => 'payAmountIndex',
        'payAmountMultiplierIndex' => 'payAmountMultiplierIndex',
        'noteIndex' => 'noteIndex',
        'payCodeIndex' => 'payCodeIndex',
        'hasPaylineCosting' => 'hasPaylineCosting',
        'departmentIndex' => 'departmentIndex',
        'costCentreIndex' => 'costCentreIndex',
        'effectiveFromIndex' => 'effectiveFromIndex',
        'effectiveToIndex' => 'effectiveToIndex',
        'isAutomaticBackPayIndex' => 'isAutomaticBackPayIndex',
        'ignoreInitialBackPayIndex' => 'ignoreInitialBackPayIndex',
        'contributesToBasicPayIndex' => 'contributesToBasicPayIndex',
        'autoAdjustForLeaveIndex' => 'autoAdjustForLeaveIndex',
        'analysisCategoryIndexesJson' => 'analysisCategoryIndexesJson',
        'paySpineIndex' => 'paySpineIndex',
        'payGradeIndex' => 'payGradeIndex',
        'spinePointIndex' => 'spinePointIndex',
        'analysisCategoryIndexes' => 'analysisCategoryIndexes',
        'columns' => 'columns',
        'id' => 'id'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'name' => 'setName',
        'type' => 'setType',
        'importBehaviour' => 'setImportBehaviour',
        'payBasis' => 'setPayBasis',
        'hasHeader' => 'setHasHeader',
        'payrollCodeIndex' => 'setPayrollCodeIndex',
        'employerIdIndex' => 'setEmployerIdIndex',
        'roleReferenceIndex' => 'setRoleReferenceIndex',
        'payAmountIndex' => 'setPayAmountIndex',
        'payAmountMultiplierIndex' => 'setPayAmountMultiplierIndex',
        'noteIndex' => 'setNoteIndex',
        'payCodeIndex' => 'setPayCodeIndex',
        'hasPaylineCosting' => 'setHasPaylineCosting',
        'departmentIndex' => 'setDepartmentIndex',
        'costCentreIndex' => 'setCostCentreIndex',
        'effectiveFromIndex' => 'setEffectiveFromIndex',
        'effectiveToIndex' => 'setEffectiveToIndex',
        'isAutomaticBackPayIndex' => 'setIsAutomaticBackPayIndex',
        'ignoreInitialBackPayIndex' => 'setIgnoreInitialBackPayIndex',
        'contributesToBasicPayIndex' => 'setContributesToBasicPayIndex',
        'autoAdjustForLeaveIndex' => 'setAutoAdjustForLeaveIndex',
        'analysisCategoryIndexesJson' => 'setAnalysisCategoryIndexesJson',
        'paySpineIndex' => 'setPaySpineIndex',
        'payGradeIndex' => 'setPayGradeIndex',
        'spinePointIndex' => 'setSpinePointIndex',
        'analysisCategoryIndexes' => 'setAnalysisCategoryIndexes',
        'columns' => 'setColumns',
        'id' => 'setId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'name' => 'getName',
        'type' => 'getType',
        'importBehaviour' => 'getImportBehaviour',
        'payBasis' => 'getPayBasis',
        'hasHeader' => 'getHasHeader',
        'payrollCodeIndex' => 'getPayrollCodeIndex',
        'employerIdIndex' => 'getEmployerIdIndex',
        'roleReferenceIndex' => 'getRoleReferenceIndex',
        'payAmountIndex' => 'getPayAmountIndex',
        'payAmountMultiplierIndex' => 'getPayAmountMultiplierIndex',
        'noteIndex' => 'getNoteIndex',
        'payCodeIndex' => 'getPayCodeIndex',
        'hasPaylineCosting' => 'getHasPaylineCosting',
        'departmentIndex' => 'getDepartmentIndex',
        'costCentreIndex' => 'getCostCentreIndex',
        'effectiveFromIndex' => 'getEffectiveFromIndex',
        'effectiveToIndex' => 'getEffectiveToIndex',
        'isAutomaticBackPayIndex' => 'getIsAutomaticBackPayIndex',
        'ignoreInitialBackPayIndex' => 'getIgnoreInitialBackPayIndex',
        'contributesToBasicPayIndex' => 'getContributesToBasicPayIndex',
        'autoAdjustForLeaveIndex' => 'getAutoAdjustForLeaveIndex',
        'analysisCategoryIndexesJson' => 'getAnalysisCategoryIndexesJson',
        'paySpineIndex' => 'getPaySpineIndex',
        'payGradeIndex' => 'getPayGradeIndex',
        'spinePointIndex' => 'getSpinePointIndex',
        'analysisCategoryIndexes' => 'getAnalysisCategoryIndexes',
        'columns' => 'getColumns',
        'id' => 'getId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('importBehaviour', $data ?? [], null);
        $this->setIfExists('payBasis', $data ?? [], null);
        $this->setIfExists('hasHeader', $data ?? [], null);
        $this->setIfExists('payrollCodeIndex', $data ?? [], null);
        $this->setIfExists('employerIdIndex', $data ?? [], null);
        $this->setIfExists('roleReferenceIndex', $data ?? [], null);
        $this->setIfExists('payAmountIndex', $data ?? [], null);
        $this->setIfExists('payAmountMultiplierIndex', $data ?? [], null);
        $this->setIfExists('noteIndex', $data ?? [], null);
        $this->setIfExists('payCodeIndex', $data ?? [], null);
        $this->setIfExists('hasPaylineCosting', $data ?? [], null);
        $this->setIfExists('departmentIndex', $data ?? [], null);
        $this->setIfExists('costCentreIndex', $data ?? [], null);
        $this->setIfExists('effectiveFromIndex', $data ?? [], null);
        $this->setIfExists('effectiveToIndex', $data ?? [], null);
        $this->setIfExists('isAutomaticBackPayIndex', $data ?? [], null);
        $this->setIfExists('ignoreInitialBackPayIndex', $data ?? [], null);
        $this->setIfExists('contributesToBasicPayIndex', $data ?? [], null);
        $this->setIfExists('autoAdjustForLeaveIndex', $data ?? [], null);
        $this->setIfExists('analysisCategoryIndexesJson', $data ?? [], null);
        $this->setIfExists('paySpineIndex', $data ?? [], null);
        $this->setIfExists('payGradeIndex', $data ?? [], null);
        $this->setIfExists('spinePointIndex', $data ?? [], null);
        $this->setIfExists('analysisCategoryIndexes', $data ?? [], null);
        $this->setIfExists('columns', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ((mb_strlen($this->container['name']) > 50)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be smaller than or equal to 50.";
        }

        if ((mb_strlen($this->container['name']) < 1)) {
            $invalidProperties[] = "invalid value for 'name', the character length must be bigger than or equal to 1.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName(): string
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name name
     *
     * @return $this
     */
    public function setName(string $name): static
    {
        if (is_null($name)) {
            throw new InvalidArgumentException('non-nullable name cannot be null');
        }
        if ((mb_strlen($name) > 50)) {
            throw new InvalidArgumentException('invalid length for $name when calling PaymentsCsvMapping., must be smaller than or equal to 50.');
        }
        if ((mb_strlen($name) < 1)) {
            throw new InvalidArgumentException('invalid length for $name when calling PaymentsCsvMapping., must be bigger than or equal to 1.');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets type
     *
     * @return \SynergiTech\Staffology\Model\PaymentsCsvMappingType|null
     */
    public function getType(): ?\SynergiTech\Staffology\Model\PaymentsCsvMappingType
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param \SynergiTech\Staffology\Model\PaymentsCsvMappingType|null $type type
     *
     * @return $this
     */
    public function setType(?\SynergiTech\Staffology\Model\PaymentsCsvMappingType $type): static
    {
        if (is_null($type)) {
            throw new InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets importBehaviour
     *
     * @return int|null
     */
    public function getImportBehaviour(): ?int
    {
        return $this->container['importBehaviour'];
    }

    /**
     * Sets importBehaviour
     *
     * @param int|null $importBehaviour importBehaviour
     *
     * @return $this
     */
    public function setImportBehaviour(?int $importBehaviour): static
    {
        if (is_null($importBehaviour)) {
            throw new InvalidArgumentException('non-nullable importBehaviour cannot be null');
        }
        $this->container['importBehaviour'] = $importBehaviour;

        return $this;
    }

    /**
     * Gets payBasis
     *
     * @return \SynergiTech\Staffology\Model\PayBasis|null
     */
    public function getPayBasis(): ?\SynergiTech\Staffology\Model\PayBasis
    {
        return $this->container['payBasis'];
    }

    /**
     * Sets payBasis
     *
     * @param \SynergiTech\Staffology\Model\PayBasis|null $payBasis payBasis
     *
     * @return $this
     */
    public function setPayBasis(?\SynergiTech\Staffology\Model\PayBasis $payBasis): static
    {
        if (is_null($payBasis)) {
            throw new InvalidArgumentException('non-nullable payBasis cannot be null');
        }
        $this->container['payBasis'] = $payBasis;

        return $this;
    }

    /**
     * Gets hasHeader
     *
     * @return bool|null
     */
    public function getHasHeader(): ?bool
    {
        return $this->container['hasHeader'];
    }

    /**
     * Sets hasHeader
     *
     * @param bool|null $hasHeader hasHeader
     *
     * @return $this
     */
    public function setHasHeader(?bool $hasHeader): static
    {
        if (is_null($hasHeader)) {
            throw new InvalidArgumentException('non-nullable hasHeader cannot be null');
        }
        $this->container['hasHeader'] = $hasHeader;

        return $this;
    }

    /**
     * Gets payrollCodeIndex
     *
     * @return int|null
     */
    public function getPayrollCodeIndex(): ?int
    {
        return $this->container['payrollCodeIndex'];
    }

    /**
     * Sets payrollCodeIndex
     *
     * @param int|null $payrollCodeIndex payrollCodeIndex
     *
     * @return $this
     */
    public function setPayrollCodeIndex(?int $payrollCodeIndex): static
    {
        if (is_null($payrollCodeIndex)) {
            throw new InvalidArgumentException('non-nullable payrollCodeIndex cannot be null');
        }
        $this->container['payrollCodeIndex'] = $payrollCodeIndex;

        return $this;
    }

    /**
     * Gets employerIdIndex
     *
     * @return int|null
     */
    public function getEmployerIdIndex(): ?int
    {
        return $this->container['employerIdIndex'];
    }

    /**
     * Sets employerIdIndex
     *
     * @param int|null $employerIdIndex employerIdIndex
     *
     * @return $this
     */
    public function setEmployerIdIndex(?int $employerIdIndex): static
    {
        if (is_null($employerIdIndex)) {
            throw new InvalidArgumentException('non-nullable employerIdIndex cannot be null');
        }
        $this->container['employerIdIndex'] = $employerIdIndex;

        return $this;
    }

    /**
     * Gets roleReferenceIndex
     *
     * @return int|null
     */
    public function getRoleReferenceIndex(): ?int
    {
        return $this->container['roleReferenceIndex'];
    }

    /**
     * Sets roleReferenceIndex
     *
     * @param int|null $roleReferenceIndex roleReferenceIndex
     *
     * @return $this
     */
    public function setRoleReferenceIndex(?int $roleReferenceIndex): static
    {
        if (is_null($roleReferenceIndex)) {
            throw new InvalidArgumentException('non-nullable roleReferenceIndex cannot be null');
        }
        $this->container['roleReferenceIndex'] = $roleReferenceIndex;

        return $this;
    }

    /**
     * Gets payAmountIndex
     *
     * @return int|null
     */
    public function getPayAmountIndex(): ?int
    {
        return $this->container['payAmountIndex'];
    }

    /**
     * Sets payAmountIndex
     *
     * @param int|null $payAmountIndex payAmountIndex
     *
     * @return $this
     */
    public function setPayAmountIndex(?int $payAmountIndex): static
    {
        if (is_null($payAmountIndex)) {
            throw new InvalidArgumentException('non-nullable payAmountIndex cannot be null');
        }
        $this->container['payAmountIndex'] = $payAmountIndex;

        return $this;
    }

    /**
     * Gets payAmountMultiplierIndex
     *
     * @return int|null
     */
    public function getPayAmountMultiplierIndex(): ?int
    {
        return $this->container['payAmountMultiplierIndex'];
    }

    /**
     * Sets payAmountMultiplierIndex
     *
     * @param int|null $payAmountMultiplierIndex payAmountMultiplierIndex
     *
     * @return $this
     */
    public function setPayAmountMultiplierIndex(?int $payAmountMultiplierIndex): static
    {
        if (is_null($payAmountMultiplierIndex)) {
            throw new InvalidArgumentException('non-nullable payAmountMultiplierIndex cannot be null');
        }
        $this->container['payAmountMultiplierIndex'] = $payAmountMultiplierIndex;

        return $this;
    }

    /**
     * Gets noteIndex
     *
     * @return int|null
     */
    public function getNoteIndex(): ?int
    {
        return $this->container['noteIndex'];
    }

    /**
     * Sets noteIndex
     *
     * @param int|null $noteIndex noteIndex
     *
     * @return $this
     */
    public function setNoteIndex(?int $noteIndex): static
    {
        if (is_null($noteIndex)) {
            throw new InvalidArgumentException('non-nullable noteIndex cannot be null');
        }
        $this->container['noteIndex'] = $noteIndex;

        return $this;
    }

    /**
     * Gets payCodeIndex
     *
     * @return int|null
     */
    public function getPayCodeIndex(): ?int
    {
        return $this->container['payCodeIndex'];
    }

    /**
     * Sets payCodeIndex
     *
     * @param int|null $payCodeIndex payCodeIndex
     *
     * @return $this
     */
    public function setPayCodeIndex(?int $payCodeIndex): static
    {
        if (is_null($payCodeIndex)) {
            throw new InvalidArgumentException('non-nullable payCodeIndex cannot be null');
        }
        $this->container['payCodeIndex'] = $payCodeIndex;

        return $this;
    }

    /**
     * Gets hasPaylineCosting
     *
     * @return bool|null
     */
    public function getHasPaylineCosting(): ?bool
    {
        return $this->container['hasPaylineCosting'];
    }

    /**
     * Sets hasPaylineCosting
     *
     * @param bool|null $hasPaylineCosting hasPaylineCosting
     *
     * @return $this
     */
    public function setHasPaylineCosting(?bool $hasPaylineCosting): static
    {
        if (is_null($hasPaylineCosting)) {
            throw new InvalidArgumentException('non-nullable hasPaylineCosting cannot be null');
        }
        $this->container['hasPaylineCosting'] = $hasPaylineCosting;

        return $this;
    }

    /**
     * Gets departmentIndex
     *
     * @return int|null
     */
    public function getDepartmentIndex(): ?int
    {
        return $this->container['departmentIndex'];
    }

    /**
     * Sets departmentIndex
     *
     * @param int|null $departmentIndex departmentIndex
     *
     * @return $this
     */
    public function setDepartmentIndex(?int $departmentIndex): static
    {
        if (is_null($departmentIndex)) {
            throw new InvalidArgumentException('non-nullable departmentIndex cannot be null');
        }
        $this->container['departmentIndex'] = $departmentIndex;

        return $this;
    }

    /**
     * Gets costCentreIndex
     *
     * @return int|null
     */
    public function getCostCentreIndex(): ?int
    {
        return $this->container['costCentreIndex'];
    }

    /**
     * Sets costCentreIndex
     *
     * @param int|null $costCentreIndex costCentreIndex
     *
     * @return $this
     */
    public function setCostCentreIndex(?int $costCentreIndex): static
    {
        if (is_null($costCentreIndex)) {
            throw new InvalidArgumentException('non-nullable costCentreIndex cannot be null');
        }
        $this->container['costCentreIndex'] = $costCentreIndex;

        return $this;
    }

    /**
     * Gets effectiveFromIndex
     *
     * @return int|null
     */
    public function getEffectiveFromIndex(): ?int
    {
        return $this->container['effectiveFromIndex'];
    }

    /**
     * Sets effectiveFromIndex
     *
     * @param int|null $effectiveFromIndex effectiveFromIndex
     *
     * @return $this
     */
    public function setEffectiveFromIndex(?int $effectiveFromIndex): static
    {
        if (is_null($effectiveFromIndex)) {
            throw new InvalidArgumentException('non-nullable effectiveFromIndex cannot be null');
        }
        $this->container['effectiveFromIndex'] = $effectiveFromIndex;

        return $this;
    }

    /**
     * Gets effectiveToIndex
     *
     * @return int|null
     */
    public function getEffectiveToIndex(): ?int
    {
        return $this->container['effectiveToIndex'];
    }

    /**
     * Sets effectiveToIndex
     *
     * @param int|null $effectiveToIndex effectiveToIndex
     *
     * @return $this
     */
    public function setEffectiveToIndex(?int $effectiveToIndex): static
    {
        if (is_null($effectiveToIndex)) {
            throw new InvalidArgumentException('non-nullable effectiveToIndex cannot be null');
        }
        $this->container['effectiveToIndex'] = $effectiveToIndex;

        return $this;
    }

    /**
     * Gets isAutomaticBackPayIndex
     *
     * @return int|null
     */
    public function getIsAutomaticBackPayIndex(): ?int
    {
        return $this->container['isAutomaticBackPayIndex'];
    }

    /**
     * Sets isAutomaticBackPayIndex
     *
     * @param int|null $isAutomaticBackPayIndex isAutomaticBackPayIndex
     *
     * @return $this
     */
    public function setIsAutomaticBackPayIndex(?int $isAutomaticBackPayIndex): static
    {
        if (is_null($isAutomaticBackPayIndex)) {
            throw new InvalidArgumentException('non-nullable isAutomaticBackPayIndex cannot be null');
        }
        $this->container['isAutomaticBackPayIndex'] = $isAutomaticBackPayIndex;

        return $this;
    }

    /**
     * Gets ignoreInitialBackPayIndex
     *
     * @return int|null
     */
    public function getIgnoreInitialBackPayIndex(): ?int
    {
        return $this->container['ignoreInitialBackPayIndex'];
    }

    /**
     * Sets ignoreInitialBackPayIndex
     *
     * @param int|null $ignoreInitialBackPayIndex ignoreInitialBackPayIndex
     *
     * @return $this
     */
    public function setIgnoreInitialBackPayIndex(?int $ignoreInitialBackPayIndex): static
    {
        if (is_null($ignoreInitialBackPayIndex)) {
            throw new InvalidArgumentException('non-nullable ignoreInitialBackPayIndex cannot be null');
        }
        $this->container['ignoreInitialBackPayIndex'] = $ignoreInitialBackPayIndex;

        return $this;
    }

    /**
     * Gets contributesToBasicPayIndex
     *
     * @return int|null
     */
    public function getContributesToBasicPayIndex(): ?int
    {
        return $this->container['contributesToBasicPayIndex'];
    }

    /**
     * Sets contributesToBasicPayIndex
     *
     * @param int|null $contributesToBasicPayIndex contributesToBasicPayIndex
     *
     * @return $this
     */
    public function setContributesToBasicPayIndex(?int $contributesToBasicPayIndex): static
    {
        if (is_null($contributesToBasicPayIndex)) {
            throw new InvalidArgumentException('non-nullable contributesToBasicPayIndex cannot be null');
        }
        $this->container['contributesToBasicPayIndex'] = $contributesToBasicPayIndex;

        return $this;
    }

    /**
     * Gets autoAdjustForLeaveIndex
     *
     * @return int|null
     */
    public function getAutoAdjustForLeaveIndex(): ?int
    {
        return $this->container['autoAdjustForLeaveIndex'];
    }

    /**
     * Sets autoAdjustForLeaveIndex
     *
     * @param int|null $autoAdjustForLeaveIndex autoAdjustForLeaveIndex
     *
     * @return $this
     */
    public function setAutoAdjustForLeaveIndex(?int $autoAdjustForLeaveIndex): static
    {
        if (is_null($autoAdjustForLeaveIndex)) {
            throw new InvalidArgumentException('non-nullable autoAdjustForLeaveIndex cannot be null');
        }
        $this->container['autoAdjustForLeaveIndex'] = $autoAdjustForLeaveIndex;

        return $this;
    }

    /**
     * Gets analysisCategoryIndexesJson
     *
     * @return string|null
     */
    public function getAnalysisCategoryIndexesJson(): ?string
    {
        return $this->container['analysisCategoryIndexesJson'];
    }

    /**
     * Sets analysisCategoryIndexesJson
     *
     * @param string|null $analysisCategoryIndexesJson analysisCategoryIndexesJson
     *
     * @return $this
     */
    public function setAnalysisCategoryIndexesJson(?string $analysisCategoryIndexesJson): static
    {
        if (is_null($analysisCategoryIndexesJson)) {
            array_push($this->openAPINullablesSetToNull, 'analysisCategoryIndexesJson');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('analysisCategoryIndexesJson', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['analysisCategoryIndexesJson'] = $analysisCategoryIndexesJson;

        return $this;
    }

    /**
     * Gets paySpineIndex
     *
     * @return int|null
     */
    public function getPaySpineIndex(): ?int
    {
        return $this->container['paySpineIndex'];
    }

    /**
     * Sets paySpineIndex
     *
     * @param int|null $paySpineIndex paySpineIndex
     *
     * @return $this
     */
    public function setPaySpineIndex(?int $paySpineIndex): static
    {
        if (is_null($paySpineIndex)) {
            throw new InvalidArgumentException('non-nullable paySpineIndex cannot be null');
        }
        $this->container['paySpineIndex'] = $paySpineIndex;

        return $this;
    }

    /**
     * Gets payGradeIndex
     *
     * @return int|null
     */
    public function getPayGradeIndex(): ?int
    {
        return $this->container['payGradeIndex'];
    }

    /**
     * Sets payGradeIndex
     *
     * @param int|null $payGradeIndex payGradeIndex
     *
     * @return $this
     */
    public function setPayGradeIndex(?int $payGradeIndex): static
    {
        if (is_null($payGradeIndex)) {
            throw new InvalidArgumentException('non-nullable payGradeIndex cannot be null');
        }
        $this->container['payGradeIndex'] = $payGradeIndex;

        return $this;
    }

    /**
     * Gets spinePointIndex
     *
     * @return int|null
     */
    public function getSpinePointIndex(): ?int
    {
        return $this->container['spinePointIndex'];
    }

    /**
     * Sets spinePointIndex
     *
     * @param int|null $spinePointIndex spinePointIndex
     *
     * @return $this
     */
    public function setSpinePointIndex(?int $spinePointIndex): static
    {
        if (is_null($spinePointIndex)) {
            throw new InvalidArgumentException('non-nullable spinePointIndex cannot be null');
        }
        $this->container['spinePointIndex'] = $spinePointIndex;

        return $this;
    }

    /**
     * Gets analysisCategoryIndexes
     *
     * @return \SynergiTech\Staffology\Model\AnalysisCategoryIndex[]|null
     */
    public function getAnalysisCategoryIndexes(): ?array
    {
        return $this->container['analysisCategoryIndexes'];
    }

    /**
     * Sets analysisCategoryIndexes
     *
     * @param \SynergiTech\Staffology\Model\AnalysisCategoryIndex[]|null $analysisCategoryIndexes analysisCategoryIndexes
     *
     * @return $this
     */
    public function setAnalysisCategoryIndexes(?array $analysisCategoryIndexes): static
    {
        if (is_null($analysisCategoryIndexes)) {
            array_push($this->openAPINullablesSetToNull, 'analysisCategoryIndexes');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('analysisCategoryIndexes', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['analysisCategoryIndexes'] = $analysisCategoryIndexes;

        return $this;
    }

    /**
     * Gets columns
     *
     * @return \SynergiTech\Staffology\Model\PaymentsCsvMappingColumn[]|null
     */
    public function getColumns(): ?array
    {
        return $this->container['columns'];
    }

    /**
     * Sets columns
     *
     * @param \SynergiTech\Staffology\Model\PaymentsCsvMappingColumn[]|null $columns columns
     *
     * @return $this
     */
    public function setColumns(?array $columns): static
    {
        if (is_null($columns)) {
            array_push($this->openAPINullablesSetToNull, 'columns');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('columns', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['columns'] = $columns;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId(): ?string
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id [readonly] The unique id of the object
     *
     * @return $this
     */
    public function setId(?string $id): static
    {
        if (is_null($id)) {
            throw new InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


