<?php
/**
 * PayRunAsyncApi
 * PHP version 8.1
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Staffology Payroll API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: duane@staffology.co.uk
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Staffology\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use SynergiTech\Staffology\ApiException;
use SynergiTech\Staffology\Configuration;
use SynergiTech\Staffology\HeaderSelector;
use SynergiTech\Staffology\ObjectSerializer;

/**
 * PayRunAsyncApi Class Doc Comment
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PayRunAsyncApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'importPayPayRunAsync' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'queueCreatePayRunPayRunAsync' => [
            'application/json',
        ],
        'queueDeletePayRunPayRunAsync' => [
            'application/json',
        ],
        'queueUpdatePayRunPayRunAsync' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation importPayPayRunAsync
     *
     * Import Pay (beta)
     *
     * @param  string $employerId employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod payPeriod (required)
     * @param  int $ordinal ordinal (required)
     * @param  bool $throwOnError throwOnError (required)
     * @param  \SynergiTech\Staffology\Model\ContractPayOptionsImportRequest[] $contractPayOptionsImportRequest contractPayOptionsImportRequest (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the pay code of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPayPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\ContractJobResponse
     */
    public function importPayPayRunAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $ordinal,
        bool $throwOnError,
        array $contractPayOptionsImportRequest,
        ?bool $linesOnly = null,
        ?bool $append = null,
        ?bool $updateExisting = null,
        string $contentType = self::contentTypes['importPayPayRunAsync'][0]
    ): \SynergiTech\Staffology\Model\ContractJobResponse
    {
        list($response) = $this->importPayPayRunAsyncWithHttpInfo($employerId, $payPeriod, $ordinal, $throwOnError, $contractPayOptionsImportRequest, $linesOnly, $append, $updateExisting, $contentType);
        return $response;
    }

    /**
     * Operation importPayPayRunAsyncWithHttpInfo
     *
     * Import Pay (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $ordinal (required)
     * @param  bool $throwOnError (required)
     * @param  \SynergiTech\Staffology\Model\ContractPayOptionsImportRequest[] $contractPayOptionsImportRequest (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the pay code of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPayPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\ContractJobResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importPayPayRunAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $ordinal,
        bool $throwOnError,
        array $contractPayOptionsImportRequest,
        ?bool $linesOnly = null,
        ?bool $append = null,
        ?bool $updateExisting = null,
        string $contentType = self::contentTypes['importPayPayRunAsync'][0]
    ): array
    {
        $request = $this->importPayPayRunAsyncRequest($employerId, $payPeriod, $ordinal, $throwOnError, $contractPayOptionsImportRequest, $linesOnly, $append, $updateExisting, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if (in_array('\SynergiTech\Staffology\Model\ContractJobResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\ContractJobResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\ContractJobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\ContractJobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importPayPayRunAsyncAsync
     *
     * Import Pay (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $ordinal (required)
     * @param  bool $throwOnError (required)
     * @param  \SynergiTech\Staffology\Model\ContractPayOptionsImportRequest[] $contractPayOptionsImportRequest (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the pay code of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPayPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importPayPayRunAsyncAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $ordinal,
        bool $throwOnError,
        array $contractPayOptionsImportRequest,
        ?bool $linesOnly = null,
        ?bool $append = null,
        ?bool $updateExisting = null,
        string $contentType = self::contentTypes['importPayPayRunAsync'][0]
    ): PromiseInterface
    {
        return $this->importPayPayRunAsyncAsyncWithHttpInfo($employerId, $payPeriod, $ordinal, $throwOnError, $contractPayOptionsImportRequest, $linesOnly, $append, $updateExisting, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importPayPayRunAsyncAsyncWithHttpInfo
     *
     * Import Pay (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $ordinal (required)
     * @param  bool $throwOnError (required)
     * @param  \SynergiTech\Staffology\Model\ContractPayOptionsImportRequest[] $contractPayOptionsImportRequest (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the pay code of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPayPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importPayPayRunAsyncAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $ordinal,
        bool $throwOnError,
        array $contractPayOptionsImportRequest,
        ?bool $linesOnly = null,
        ?bool $append = null,
        ?bool $updateExisting = null,
        string $contentType = self::contentTypes['importPayPayRunAsync'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
        $request = $this->importPayPayRunAsyncRequest($employerId, $payPeriod, $ordinal, $throwOnError, $contractPayOptionsImportRequest, $linesOnly, $append, $updateExisting, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importPayPayRunAsync'
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $ordinal (required)
     * @param  bool $throwOnError (required)
     * @param  \SynergiTech\Staffology\Model\ContractPayOptionsImportRequest[] $contractPayOptionsImportRequest (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the pay code of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. Defaults to false. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPayPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importPayPayRunAsyncRequest(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $ordinal,
        bool $throwOnError,
        array $contractPayOptionsImportRequest,
        ?bool $linesOnly = null,
        ?bool $append = null,
        ?bool $updateExisting = null,
        string $contentType = self::contentTypes['importPayPayRunAsync'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling importPayPayRunAsync'
            );
        }

        // verify the required parameter 'payPeriod' is set
        if ($payPeriod === null || (is_array($payPeriod) && count($payPeriod) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $payPeriod when calling importPayPayRunAsync'
            );
        }

        // verify the required parameter 'ordinal' is set
        if ($ordinal === null || (is_array($ordinal) && count($ordinal) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ordinal when calling importPayPayRunAsync'
            );
        }

        // verify the required parameter 'throwOnError' is set
        if ($throwOnError === null || (is_array($throwOnError) && count($throwOnError) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $throwOnError when calling importPayPayRunAsync'
            );
        }

        // verify the required parameter 'contractPayOptionsImportRequest' is set
        if ($contractPayOptionsImportRequest === null || (is_array($contractPayOptionsImportRequest) && count($contractPayOptionsImportRequest) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contractPayOptionsImportRequest when calling importPayPayRunAsync'
            );
        }





        $resourcePath = '/employers/{employerId}/payrun-async/{payPeriod}/importpay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordinal,
            'ordinal', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linesOnly,
            'LinesOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $append,
            'Append', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updateExisting,
            'UpdateExisting', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $throwOnError,
            'throwOnError', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($payPeriod !== null) {
            $resourcePath = str_replace(
                '{' . 'payPeriod' . '}',
                ObjectSerializer::toPathValue($payPeriod->value),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contractPayOptionsImportRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contractPayOptionsImportRequest));
            } else {
                $httpBody = $contractPayOptionsImportRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queueCreatePayRunPayRunAsync
     *
     * Registers a request to start the next PayRun (beta)
     *
     * @param  string $employerId employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod payPeriod (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear taxYear (required)
     * @param  int|null $ordinal ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueCreatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function queueCreatePayRunPayRunAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueCreatePayRunPayRunAsync'][0]
    ): void
    {
        $this->queueCreatePayRunPayRunAsyncWithHttpInfo($employerId, $payPeriod, $taxYear, $ordinal, $contentType);
    }

    /**
     * Operation queueCreatePayRunPayRunAsyncWithHttpInfo
     *
     * Registers a request to start the next PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueCreatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function queueCreatePayRunPayRunAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueCreatePayRunPayRunAsync'][0]
    ): array
    {
        $request = $this->queueCreatePayRunPayRunAsyncRequest($employerId, $payPeriod, $taxYear, $ordinal, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation queueCreatePayRunPayRunAsyncAsync
     *
     * Registers a request to start the next PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueCreatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueCreatePayRunPayRunAsyncAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueCreatePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        return $this->queueCreatePayRunPayRunAsyncAsyncWithHttpInfo($employerId, $payPeriod, $taxYear, $ordinal, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queueCreatePayRunPayRunAsyncAsyncWithHttpInfo
     *
     * Registers a request to start the next PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueCreatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueCreatePayRunPayRunAsyncAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueCreatePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->queueCreatePayRunPayRunAsyncRequest($employerId, $payPeriod, $taxYear, $ordinal, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queueCreatePayRunPayRunAsync'
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueCreatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queueCreatePayRunPayRunAsyncRequest(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueCreatePayRunPayRunAsync'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling queueCreatePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'payPeriod' is set
        if ($payPeriod === null || (is_array($payPeriod) && count($payPeriod) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $payPeriod when calling queueCreatePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'taxYear' is set
        if ($taxYear === null || (is_array($taxYear) && count($taxYear) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taxYear when calling queueCreatePayRunPayRunAsync'
            );
        }



        $resourcePath = '/employers/{employerId}/payrun-async/{taxYear}/{payPeriod}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordinal,
            'ordinal', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($payPeriod !== null) {
            $resourcePath = str_replace(
                '{' . 'payPeriod' . '}',
                ObjectSerializer::toPathValue($payPeriod->value),
                $resourcePath
            );
        }
        // path params
        if ($taxYear !== null) {
            $resourcePath = str_replace(
                '{' . 'taxYear' . '}',
                ObjectSerializer::toPathValue($taxYear->value),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queueDeletePayRunPayRunAsync
     *
     * Registers a request to delete a PayRun (beta)
     *
     * @param  string $employerId employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod payPeriod (required)
     * @param  int $periodNumber periodNumber (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear taxYear (required)
     * @param  int|null $ordinal ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueDeletePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function queueDeletePayRunPayRunAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueDeletePayRunPayRunAsync'][0]
    ): void
    {
        $this->queueDeletePayRunPayRunAsyncWithHttpInfo($employerId, $payPeriod, $periodNumber, $taxYear, $ordinal, $contentType);
    }

    /**
     * Operation queueDeletePayRunPayRunAsyncWithHttpInfo
     *
     * Registers a request to delete a PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueDeletePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function queueDeletePayRunPayRunAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueDeletePayRunPayRunAsync'][0]
    ): array
    {
        $request = $this->queueDeletePayRunPayRunAsyncRequest($employerId, $payPeriod, $periodNumber, $taxYear, $ordinal, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation queueDeletePayRunPayRunAsyncAsync
     *
     * Registers a request to delete a PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueDeletePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueDeletePayRunPayRunAsyncAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueDeletePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        return $this->queueDeletePayRunPayRunAsyncAsyncWithHttpInfo($employerId, $payPeriod, $periodNumber, $taxYear, $ordinal, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queueDeletePayRunPayRunAsyncAsyncWithHttpInfo
     *
     * Registers a request to delete a PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueDeletePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueDeletePayRunPayRunAsyncAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueDeletePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->queueDeletePayRunPayRunAsyncRequest($employerId, $payPeriod, $periodNumber, $taxYear, $ordinal, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queueDeletePayRunPayRunAsync'
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueDeletePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queueDeletePayRunPayRunAsyncRequest(
        string $employerId,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        ?int $ordinal = 1,
        string $contentType = self::contentTypes['queueDeletePayRunPayRunAsync'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling queueDeletePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'payPeriod' is set
        if ($payPeriod === null || (is_array($payPeriod) && count($payPeriod) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $payPeriod when calling queueDeletePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'periodNumber' is set
        if ($periodNumber === null || (is_array($periodNumber) && count($periodNumber) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $periodNumber when calling queueDeletePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'taxYear' is set
        if ($taxYear === null || (is_array($taxYear) && count($taxYear) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taxYear when calling queueDeletePayRunPayRunAsync'
            );
        }



        $resourcePath = '/employers/{employerId}/payrun-async/{taxYear}/{payPeriod}/{periodNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordinal,
            'ordinal', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($payPeriod !== null) {
            $resourcePath = str_replace(
                '{' . 'payPeriod' . '}',
                ObjectSerializer::toPathValue($payPeriod->value),
                $resourcePath
            );
        }
        // path params
        if ($periodNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'periodNumber' . '}',
                ObjectSerializer::toPathValue($periodNumber),
                $resourcePath
            );
        }
        // path params
        if ($taxYear !== null) {
            $resourcePath = str_replace(
                '{' . 'taxYear' . '}',
                ObjectSerializer::toPathValue($taxYear->value),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queueUpdatePayRunPayRunAsync
     *
     * Registers a request to update the PayRun (beta)
     *
     * @param  string $employerId employerId (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear taxYear (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod payPeriod (required)
     * @param  int $periodNumber periodNumber (required)
     * @param  int|null $ordinal ordinal (optional, default to 1)
     * @param  bool|null $sendPayslipEmails sendPayslipEmails (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayslipReleaseType|null $payslipReleaseType payslipReleaseType (optional)
     * @param  \DateTime|null $payslipScheduledDateTime payslipScheduledDateTime (optional)
     * @param  \SynergiTech\Staffology\Model\PayRunStateChange|null $payRunStateChange payRunStateChange (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueUpdatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\PayRun
     */
    public function queueUpdatePayRunPayRunAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        ?int $ordinal = 1,
        ?bool $sendPayslipEmails = false,
        ?\SynergiTech\Staffology\Model\PayslipReleaseType $payslipReleaseType = null,
        ?\DateTime $payslipScheduledDateTime = null,
        ?\SynergiTech\Staffology\Model\PayRunStateChange $payRunStateChange = null,
        string $contentType = self::contentTypes['queueUpdatePayRunPayRunAsync'][0]
    ): \SynergiTech\Staffology\Model\PayRun
    {
        list($response) = $this->queueUpdatePayRunPayRunAsyncWithHttpInfo($employerId, $taxYear, $payPeriod, $periodNumber, $ordinal, $sendPayslipEmails, $payslipReleaseType, $payslipScheduledDateTime, $payRunStateChange, $contentType);
        return $response;
    }

    /**
     * Operation queueUpdatePayRunPayRunAsyncWithHttpInfo
     *
     * Registers a request to update the PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  bool|null $sendPayslipEmails (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayslipReleaseType|null $payslipReleaseType (optional)
     * @param  \DateTime|null $payslipScheduledDateTime (optional)
     * @param  \SynergiTech\Staffology\Model\PayRunStateChange|null $payRunStateChange (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueUpdatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\PayRun|\SynergiTech\Staffology\Model\PayRun, HTTP status code, HTTP response headers (array of strings)
     */
    public function queueUpdatePayRunPayRunAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        ?int $ordinal = 1,
        ?bool $sendPayslipEmails = false,
        ?\SynergiTech\Staffology\Model\PayslipReleaseType $payslipReleaseType = null,
        ?\DateTime $payslipScheduledDateTime = null,
        ?\SynergiTech\Staffology\Model\PayRunStateChange $payRunStateChange = null,
        string $contentType = self::contentTypes['queueUpdatePayRunPayRunAsync'][0]
    ): array
    {
        $request = $this->queueUpdatePayRunPayRunAsyncRequest($employerId, $taxYear, $payPeriod, $periodNumber, $ordinal, $sendPayslipEmails, $payslipReleaseType, $payslipScheduledDateTime, $payRunStateChange, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\PayRun', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\PayRun' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\PayRun', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if (in_array('\SynergiTech\Staffology\Model\PayRun', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\PayRun' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\PayRun', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\PayRun';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\PayRun',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\PayRun',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queueUpdatePayRunPayRunAsyncAsync
     *
     * Registers a request to update the PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  bool|null $sendPayslipEmails (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayslipReleaseType|null $payslipReleaseType (optional)
     * @param  \DateTime|null $payslipScheduledDateTime (optional)
     * @param  \SynergiTech\Staffology\Model\PayRunStateChange|null $payRunStateChange (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueUpdatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueUpdatePayRunPayRunAsyncAsync(
        string $employerId,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        ?int $ordinal = 1,
        ?bool $sendPayslipEmails = false,
        ?\SynergiTech\Staffology\Model\PayslipReleaseType $payslipReleaseType = null,
        ?\DateTime $payslipScheduledDateTime = null,
        ?\SynergiTech\Staffology\Model\PayRunStateChange $payRunStateChange = null,
        string $contentType = self::contentTypes['queueUpdatePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        return $this->queueUpdatePayRunPayRunAsyncAsyncWithHttpInfo($employerId, $taxYear, $payPeriod, $periodNumber, $ordinal, $sendPayslipEmails, $payslipReleaseType, $payslipScheduledDateTime, $payRunStateChange, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queueUpdatePayRunPayRunAsyncAsyncWithHttpInfo
     *
     * Registers a request to update the PayRun (beta)
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  bool|null $sendPayslipEmails (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayslipReleaseType|null $payslipReleaseType (optional)
     * @param  \DateTime|null $payslipScheduledDateTime (optional)
     * @param  \SynergiTech\Staffology\Model\PayRunStateChange|null $payRunStateChange (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueUpdatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function queueUpdatePayRunPayRunAsyncAsyncWithHttpInfo(
        string $employerId,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        ?int $ordinal = 1,
        ?bool $sendPayslipEmails = false,
        ?\SynergiTech\Staffology\Model\PayslipReleaseType $payslipReleaseType = null,
        ?\DateTime $payslipScheduledDateTime = null,
        ?\SynergiTech\Staffology\Model\PayRunStateChange $payRunStateChange = null,
        string $contentType = self::contentTypes['queueUpdatePayRunPayRunAsync'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\PayRun';
        $request = $this->queueUpdatePayRunPayRunAsyncRequest($employerId, $taxYear, $payPeriod, $periodNumber, $ordinal, $sendPayslipEmails, $payslipReleaseType, $payslipScheduledDateTime, $payRunStateChange, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queueUpdatePayRunPayRunAsync'
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\TaxYear $taxYear (required)
     * @param  \SynergiTech\Staffology\Model\PayPeriods $payPeriod (required)
     * @param  int $periodNumber (required)
     * @param  int|null $ordinal (optional, default to 1)
     * @param  bool|null $sendPayslipEmails (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayslipReleaseType|null $payslipReleaseType (optional)
     * @param  \DateTime|null $payslipScheduledDateTime (optional)
     * @param  \SynergiTech\Staffology\Model\PayRunStateChange|null $payRunStateChange (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queueUpdatePayRunPayRunAsync'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queueUpdatePayRunPayRunAsyncRequest(
        string $employerId,
        \SynergiTech\Staffology\Model\TaxYear $taxYear,
        \SynergiTech\Staffology\Model\PayPeriods $payPeriod,
        int $periodNumber,
        ?int $ordinal = 1,
        ?bool $sendPayslipEmails = false,
        ?\SynergiTech\Staffology\Model\PayslipReleaseType $payslipReleaseType = null,
        ?\DateTime $payslipScheduledDateTime = null,
        ?\SynergiTech\Staffology\Model\PayRunStateChange $payRunStateChange = null,
        string $contentType = self::contentTypes['queueUpdatePayRunPayRunAsync'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling queueUpdatePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'taxYear' is set
        if ($taxYear === null || (is_array($taxYear) && count($taxYear) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $taxYear when calling queueUpdatePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'payPeriod' is set
        if ($payPeriod === null || (is_array($payPeriod) && count($payPeriod) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $payPeriod when calling queueUpdatePayRunPayRunAsync'
            );
        }

        // verify the required parameter 'periodNumber' is set
        if ($periodNumber === null || (is_array($periodNumber) && count($periodNumber) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $periodNumber when calling queueUpdatePayRunPayRunAsync'
            );
        }







        $resourcePath = '/employers/{employerId}/payrun-async/{taxYear}/{payPeriod}/{periodNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ordinal,
            'ordinal', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sendPayslipEmails,
            'sendPayslipEmails', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payslipReleaseType?->value,
            'payslipReleaseType', // param base name
            'PayslipReleaseType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payslipScheduledDateTime,
            'payslipScheduledDateTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($taxYear !== null) {
            $resourcePath = str_replace(
                '{' . 'taxYear' . '}',
                ObjectSerializer::toPathValue($taxYear->value),
                $resourcePath
            );
        }
        // path params
        if ($payPeriod !== null) {
            $resourcePath = str_replace(
                '{' . 'payPeriod' . '}',
                ObjectSerializer::toPathValue($payPeriod->value),
                $resourcePath
            );
        }
        // path params
        if ($periodNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'periodNumber' . '}',
                ObjectSerializer::toPathValue($periodNumber),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payRunStateChange)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payRunStateChange));
            } else {
                $httpBody = $payRunStateChange;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
