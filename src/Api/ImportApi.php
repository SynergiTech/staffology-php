<?php
/**
 * ImportApi
 * PHP version 8.1
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Staffology Payroll API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: duane@staffology.co.uk
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Staffology\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use SynergiTech\Staffology\ApiException;
use SynergiTech\Staffology\Configuration;
use SynergiTech\Staffology\HeaderSelector;
use SynergiTech\Staffology\ObjectSerializer;

/**
 * ImportApi Class Doc Comment
 *
 * @package  SynergiTech\Staffology
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ImportApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createPaymentsCsvMappingImport' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'deletePaymentCsvMappingImport' => [
            'application/json',
        ],
        'employeeImportCsvImport' => [
            'multipart/form-data',
        ],
        'importEmployeePayImport' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'importLeaveImport' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'importPensionMembershipsImport' => [
            'multipart/form-data',
        ],
        'importRolesImport' => [
            'multipart/form-data',
        ],
        'listPaymentsCsvMappingsImport' => [
            'application/json',
        ],
        'paymentsCsvMappingCsvFileImport' => [
            'application/json',
        ],
        'paymentsCsvMappingImport' => [
            'application/json',
        ],
        'updatePaymentsCsvMappingImport' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation createPaymentsCsvMappingImport
     *
     * Create PaymentsCsvMapping
     *
     * @param  string $employerId employerId (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function createPaymentsCsvMappingImport(
        string $employerId,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['createPaymentsCsvMappingImport'][0]
    ): void
    {
        $this->createPaymentsCsvMappingImportWithHttpInfo($employerId, $paymentsCsvMapping, $contentType);
    }

    /**
     * Operation createPaymentsCsvMappingImportWithHttpInfo
     *
     * Create PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentsCsvMappingImportWithHttpInfo(
        string $employerId,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['createPaymentsCsvMappingImport'][0]
    ): array
    {
        $request = $this->createPaymentsCsvMappingImportRequest($employerId, $paymentsCsvMapping, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentsCsvMappingImportAsync
     *
     * Create PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createPaymentsCsvMappingImportAsync(
        string $employerId,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['createPaymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        return $this->createPaymentsCsvMappingImportAsyncWithHttpInfo($employerId, $paymentsCsvMapping, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentsCsvMappingImportAsyncWithHttpInfo
     *
     * Create PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createPaymentsCsvMappingImportAsyncWithHttpInfo(
        $employerId,
        $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['createPaymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->createPaymentsCsvMappingImportRequest($employerId, $paymentsCsvMapping, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPaymentsCsvMappingImport'
     *
     * @param  string $employerId (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPaymentsCsvMappingImportRequest(
        $employerId,
        $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['createPaymentsCsvMappingImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling createPaymentsCsvMappingImport'
            );
        }



        $resourcePath = '/employers/{employerId}/import/payments/mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($paymentsCsvMapping)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentsCsvMapping));
            } else {
                $httpBody = $paymentsCsvMapping;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePaymentCsvMappingImport
     *
     * Delete PaymentsCsvMapping
     *
     * @param  string $employerId employerId (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePaymentCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deletePaymentCsvMappingImport(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['deletePaymentCsvMappingImport'][0]
    ): void
    {
        $this->deletePaymentCsvMappingImportWithHttpInfo($employerId, $id, $contentType);
    }

    /**
     * Operation deletePaymentCsvMappingImportWithHttpInfo
     *
     * Delete PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePaymentCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePaymentCsvMappingImportWithHttpInfo(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['deletePaymentCsvMappingImport'][0]
    ): array
    {
        $request = $this->deletePaymentCsvMappingImportRequest($employerId, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deletePaymentCsvMappingImportAsync
     *
     * Delete PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePaymentCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deletePaymentCsvMappingImportAsync(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['deletePaymentCsvMappingImport'][0]
    ): PromiseInterface
    {
        return $this->deletePaymentCsvMappingImportAsyncWithHttpInfo($employerId, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePaymentCsvMappingImportAsyncWithHttpInfo
     *
     * Delete PaymentsCsvMapping
     *
     * @param  string $employerId (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePaymentCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deletePaymentCsvMappingImportAsyncWithHttpInfo(
        $employerId,
        $id,
        string $contentType = self::contentTypes['deletePaymentCsvMappingImport'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deletePaymentCsvMappingImportRequest($employerId, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePaymentCsvMappingImport'
     *
     * @param  string $employerId (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePaymentCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePaymentCsvMappingImportRequest(
        $employerId,
        $id,
        string $contentType = self::contentTypes['deletePaymentCsvMappingImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling deletePaymentCsvMappingImport'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling deletePaymentCsvMappingImport'
            );
        }


        $resourcePath = '/employers/{employerId}/import/payments/mappings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation employeeImportCsvImport
     *
     * Import Employees Asynchronously (Beta)
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\CsvFileFormat|null $format The CSV format. (optional)
     * @param  bool|null $allowUpdates If set to true, and if the payroll code matches an existing employee, then that employee will be updated. (optional, default to false)
     * @param  \SplFileObject|null $file file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeImportCsvImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\ContractJobResponse
     */
    public function employeeImportCsvImport(
        string $employerId,
        ?\SynergiTech\Staffology\Model\CsvFileFormat $format = null,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['employeeImportCsvImport'][0]
    ): \SynergiTech\Staffology\Model\ContractJobResponse
    {
        list($response) = $this->employeeImportCsvImportWithHttpInfo($employerId, $format, $allowUpdates, $file, $contentType);
        return $response;
    }

    /**
     * Operation employeeImportCsvImportWithHttpInfo
     *
     * Import Employees Asynchronously (Beta)
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\CsvFileFormat|null $format The CSV format. (optional)
     * @param  bool|null $allowUpdates If set to true, and if the payroll code matches an existing employee, then that employee will be updated. (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeImportCsvImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\ContractJobResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function employeeImportCsvImportWithHttpInfo(
        string $employerId,
        ?\SynergiTech\Staffology\Model\CsvFileFormat $format = null,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['employeeImportCsvImport'][0]
    ): array
    {
        $request = $this->employeeImportCsvImportRequest($employerId, $format, $allowUpdates, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if (in_array('\SynergiTech\Staffology\Model\ContractJobResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\ContractJobResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\ContractJobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\ContractJobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation employeeImportCsvImportAsync
     *
     * Import Employees Asynchronously (Beta)
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\CsvFileFormat|null $format The CSV format. (optional)
     * @param  bool|null $allowUpdates If set to true, and if the payroll code matches an existing employee, then that employee will be updated. (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeImportCsvImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function employeeImportCsvImportAsync(
        string $employerId,
        ?\SynergiTech\Staffology\Model\CsvFileFormat $format = null,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['employeeImportCsvImport'][0]
    ): PromiseInterface
    {
        return $this->employeeImportCsvImportAsyncWithHttpInfo($employerId, $format, $allowUpdates, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation employeeImportCsvImportAsyncWithHttpInfo
     *
     * Import Employees Asynchronously (Beta)
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\CsvFileFormat|null $format The CSV format. (optional)
     * @param  bool|null $allowUpdates If set to true, and if the payroll code matches an existing employee, then that employee will be updated. (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeImportCsvImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function employeeImportCsvImportAsyncWithHttpInfo(
        $employerId,
        $format = null,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['employeeImportCsvImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
        $request = $this->employeeImportCsvImportRequest($employerId, $format, $allowUpdates, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'employeeImportCsvImport'
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\CsvFileFormat|null $format The CSV format. (optional)
     * @param  bool|null $allowUpdates If set to true, and if the payroll code matches an existing employee, then that employee will be updated. (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['employeeImportCsvImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function employeeImportCsvImportRequest(
        $employerId,
        $format = null,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['employeeImportCsvImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling employeeImportCsvImport'
            );
        }





        $resourcePath = '/employers/{employerId}/import/employees/async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'CsvFileFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allowUpdates,
            'allowUpdates', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importEmployeePayImport
     *
     * Import Pay To Employee
     *
     * @param  string $employerId employerId (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional, default to false)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional, default to false)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the paycode of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. (optional, default to false)
     * @param  bool|null $validateOnly If set to true, the import will only be validated for data correctness. If false, the import is validated and then imported. (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayOptionsImport[]|null $payOptionsImport payOptionsImport (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importEmployeePayImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function importEmployeePayImport(
        string $employerId,
        ?bool $linesOnly = false,
        ?bool $append = false,
        ?bool $updateExisting = false,
        ?bool $validateOnly = false,
        ?array $payOptionsImport = null,
        string $contentType = self::contentTypes['importEmployeePayImport'][0]
    ): void
    {
        $this->importEmployeePayImportWithHttpInfo($employerId, $linesOnly, $append, $updateExisting, $validateOnly, $payOptionsImport, $contentType);
    }

    /**
     * Operation importEmployeePayImportWithHttpInfo
     *
     * Import Pay To Employee
     *
     * @param  string $employerId (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional, default to false)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional, default to false)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the paycode of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. (optional, default to false)
     * @param  bool|null $validateOnly If set to true, the import will only be validated for data correctness. If false, the import is validated and then imported. (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayOptionsImport[]|null $payOptionsImport (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importEmployeePayImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function importEmployeePayImportWithHttpInfo(
        string $employerId,
        ?bool $linesOnly = false,
        ?bool $append = false,
        ?bool $updateExisting = false,
        ?bool $validateOnly = false,
        ?array $payOptionsImport = null,
        string $contentType = self::contentTypes['importEmployeePayImport'][0]
    ): array
    {
        $request = $this->importEmployeePayImportRequest($employerId, $linesOnly, $append, $updateExisting, $validateOnly, $payOptionsImport, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation importEmployeePayImportAsync
     *
     * Import Pay To Employee
     *
     * @param  string $employerId (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional, default to false)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional, default to false)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the paycode of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. (optional, default to false)
     * @param  bool|null $validateOnly If set to true, the import will only be validated for data correctness. If false, the import is validated and then imported. (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayOptionsImport[]|null $payOptionsImport (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importEmployeePayImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importEmployeePayImportAsync(
        string $employerId,
        ?bool $linesOnly = false,
        ?bool $append = false,
        ?bool $updateExisting = false,
        ?bool $validateOnly = false,
        ?array $payOptionsImport = null,
        string $contentType = self::contentTypes['importEmployeePayImport'][0]
    ): PromiseInterface
    {
        return $this->importEmployeePayImportAsyncWithHttpInfo($employerId, $linesOnly, $append, $updateExisting, $validateOnly, $payOptionsImport, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importEmployeePayImportAsyncWithHttpInfo
     *
     * Import Pay To Employee
     *
     * @param  string $employerId (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional, default to false)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional, default to false)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the paycode of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. (optional, default to false)
     * @param  bool|null $validateOnly If set to true, the import will only be validated for data correctness. If false, the import is validated and then imported. (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayOptionsImport[]|null $payOptionsImport (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importEmployeePayImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importEmployeePayImportAsyncWithHttpInfo(
        $employerId,
        $linesOnly = false,
        $append = false,
        $updateExisting = false,
        $validateOnly = false,
        $payOptionsImport = null,
        string $contentType = self::contentTypes['importEmployeePayImport'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->importEmployeePayImportRequest($employerId, $linesOnly, $append, $updateExisting, $validateOnly, $payOptionsImport, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importEmployeePayImport'
     *
     * @param  string $employerId (required)
     * @param  bool|null $linesOnly If set to true then only lines will be imported. Changes to regular pay will be ignored. Defaults to false. (optional, default to false)
     * @param  bool|null $append If set to true then the lines submitted will be appended to existing lines rather than replace them. Defaults to false. (optional, default to false)
     * @param  bool|null $updateExisting If set to true then any submitted lines that match the paycode of one (and only one) existing line will be used to update the value of that lines. Any unmatched lines will be appended to existing lines. (optional, default to false)
     * @param  bool|null $validateOnly If set to true, the import will only be validated for data correctness. If false, the import is validated and then imported. (optional, default to false)
     * @param  \SynergiTech\Staffology\Model\PayOptionsImport[]|null $payOptionsImport (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importEmployeePayImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importEmployeePayImportRequest(
        $employerId,
        $linesOnly = false,
        $append = false,
        $updateExisting = false,
        $validateOnly = false,
        $payOptionsImport = null,
        string $contentType = self::contentTypes['importEmployeePayImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling importEmployeePayImport'
            );
        }







        $resourcePath = '/employers/{employerId}/import/pay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $linesOnly,
            'linesOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $append,
            'append', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updateExisting,
            'updateExisting', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validateOnly,
            'validateOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payOptionsImport)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payOptionsImport));
            } else {
                $httpBody = $payOptionsImport;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importLeaveImport
     *
     * Import Leave Asynchronously
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\ContractLeaveImportRequest[]|null $contractLeaveImportRequest The import leave items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importLeaveImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\ContractJobResponse
     */
    public function importLeaveImport(
        string $employerId,
        ?array $contractLeaveImportRequest = null,
        string $contentType = self::contentTypes['importLeaveImport'][0]
    ): \SynergiTech\Staffology\Model\ContractJobResponse
    {
        list($response) = $this->importLeaveImportWithHttpInfo($employerId, $contractLeaveImportRequest, $contentType);
        return $response;
    }

    /**
     * Operation importLeaveImportWithHttpInfo
     *
     * Import Leave Asynchronously
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\ContractLeaveImportRequest[]|null $contractLeaveImportRequest The import leave items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importLeaveImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\ContractJobResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function importLeaveImportWithHttpInfo(
        string $employerId,
        ?array $contractLeaveImportRequest = null,
        string $contentType = self::contentTypes['importLeaveImport'][0]
    ): array
    {
        $request = $this->importLeaveImportRequest($employerId, $contractLeaveImportRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if (in_array('\SynergiTech\Staffology\Model\ContractJobResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\ContractJobResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\ContractJobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\ContractJobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importLeaveImportAsync
     *
     * Import Leave Asynchronously
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\ContractLeaveImportRequest[]|null $contractLeaveImportRequest The import leave items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importLeaveImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importLeaveImportAsync(
        string $employerId,
        ?array $contractLeaveImportRequest = null,
        string $contentType = self::contentTypes['importLeaveImport'][0]
    ): PromiseInterface
    {
        return $this->importLeaveImportAsyncWithHttpInfo($employerId, $contractLeaveImportRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importLeaveImportAsyncWithHttpInfo
     *
     * Import Leave Asynchronously
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\ContractLeaveImportRequest[]|null $contractLeaveImportRequest The import leave items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importLeaveImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importLeaveImportAsyncWithHttpInfo(
        $employerId,
        $contractLeaveImportRequest = null,
        string $contentType = self::contentTypes['importLeaveImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\ContractJobResponse';
        $request = $this->importLeaveImportRequest($employerId, $contractLeaveImportRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importLeaveImport'
     *
     * @param  string $employerId The employer id. (required)
     * @param  \SynergiTech\Staffology\Model\ContractLeaveImportRequest[]|null $contractLeaveImportRequest The import leave items. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importLeaveImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importLeaveImportRequest(
        $employerId,
        $contractLeaveImportRequest = null,
        string $contentType = self::contentTypes['importLeaveImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling importLeaveImport'
            );
        }



        $resourcePath = '/employers/{employerId}/import/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contractLeaveImportRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contractLeaveImportRequest));
            } else {
                $httpBody = $contractLeaveImportRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importPensionMembershipsImport
     *
     * Import PensionMemberships from csv file
     *
     * @param  string $employerId employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPensionMembershipsImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\Item[]
     */
    public function importPensionMembershipsImport(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importPensionMembershipsImport'][0]
    ): array
    {
        list($response) = $this->importPensionMembershipsImportWithHttpInfo($employerId, $previewOnly, $allowUpdates, $file, $contentType);
        return $response;
    }

    /**
     * Operation importPensionMembershipsImportWithHttpInfo
     *
     * Import PensionMemberships from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPensionMembershipsImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\Item[], HTTP status code, HTTP response headers (array of strings)
     */
    public function importPensionMembershipsImportWithHttpInfo(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importPensionMembershipsImport'][0]
    ): array
    {
        $request = $this->importPensionMembershipsImportRequest($employerId, $previewOnly, $allowUpdates, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\Item[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\Item[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\Item[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\Item[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\Item[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importPensionMembershipsImportAsync
     *
     * Import PensionMemberships from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPensionMembershipsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importPensionMembershipsImportAsync(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importPensionMembershipsImport'][0]
    ): PromiseInterface
    {
        return $this->importPensionMembershipsImportAsyncWithHttpInfo($employerId, $previewOnly, $allowUpdates, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importPensionMembershipsImportAsyncWithHttpInfo
     *
     * Import PensionMemberships from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPensionMembershipsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importPensionMembershipsImportAsyncWithHttpInfo(
        $employerId,
        $previewOnly = false,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['importPensionMembershipsImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\Item[]';
        $request = $this->importPensionMembershipsImportRequest($employerId, $previewOnly, $allowUpdates, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importPensionMembershipsImport'
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importPensionMembershipsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importPensionMembershipsImportRequest(
        $employerId,
        $previewOnly = false,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['importPensionMembershipsImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling importPensionMembershipsImport'
            );
        }





        $resourcePath = '/employers/{employerId}/import/pensionmemberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $previewOnly,
            'previewOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allowUpdates,
            'allowUpdates', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importRolesImport
     *
     * Import EmployeeRoles from csv file
     *
     * @param  string $employerId employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importRolesImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\Item[]
     */
    public function importRolesImport(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importRolesImport'][0]
    ): array
    {
        list($response) = $this->importRolesImportWithHttpInfo($employerId, $previewOnly, $allowUpdates, $file, $contentType);
        return $response;
    }

    /**
     * Operation importRolesImportWithHttpInfo
     *
     * Import EmployeeRoles from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importRolesImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\Item[], HTTP status code, HTTP response headers (array of strings)
     */
    public function importRolesImportWithHttpInfo(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importRolesImport'][0]
    ): array
    {
        $request = $this->importRolesImportRequest($employerId, $previewOnly, $allowUpdates, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\Item[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\Item[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\Item[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\Item[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\Item[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importRolesImportAsync
     *
     * Import EmployeeRoles from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importRolesImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importRolesImportAsync(
        string $employerId,
        ?bool $previewOnly = false,
        ?bool $allowUpdates = false,
        ?\SplFileObject $file = null,
        string $contentType = self::contentTypes['importRolesImport'][0]
    ): PromiseInterface
    {
        return $this->importRolesImportAsyncWithHttpInfo($employerId, $previewOnly, $allowUpdates, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importRolesImportAsyncWithHttpInfo
     *
     * Import EmployeeRoles from csv file
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importRolesImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function importRolesImportAsyncWithHttpInfo(
        $employerId,
        $previewOnly = false,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['importRolesImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\Item[]';
        $request = $this->importRolesImportRequest($employerId, $previewOnly, $allowUpdates, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importRolesImport'
     *
     * @param  string $employerId (required)
     * @param  bool|null $previewOnly Set to true and nothing will be imported but you&#39;ll be shown a preview of the data. (optional, default to false)
     * @param  bool|null $allowUpdates (optional, default to false)
     * @param  \SplFileObject|null $file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['importRolesImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function importRolesImportRequest(
        $employerId,
        $previewOnly = false,
        $allowUpdates = false,
        $file = null,
        string $contentType = self::contentTypes['importRolesImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling importRolesImport'
            );
        }





        $resourcePath = '/employers/{employerId}/import/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $previewOnly,
            'previewOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $allowUpdates,
            'allowUpdates', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = $paramFile instanceof \Psr\Http\Message\StreamInterface
                    ? $paramFile
                    : \GuzzleHttp\Psr7\Utils::tryFopen(
                        ObjectSerializer::toFormValue($paramFile),
                        'rb'
                    );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPaymentsCsvMappingsImport
     *
     * List PaymentsCsvMappings
     *
     * @param  string $employerId The Id of the Employer for which you want to list mappings (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCsvMappingsImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\Item[]
     */
    public function listPaymentsCsvMappingsImport(
        string $employerId,
        string $contentType = self::contentTypes['listPaymentsCsvMappingsImport'][0]
    ): array
    {
        list($response) = $this->listPaymentsCsvMappingsImportWithHttpInfo($employerId, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentsCsvMappingsImportWithHttpInfo
     *
     * List PaymentsCsvMappings
     *
     * @param  string $employerId The Id of the Employer for which you want to list mappings (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCsvMappingsImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\Item[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentsCsvMappingsImportWithHttpInfo(
        string $employerId,
        string $contentType = self::contentTypes['listPaymentsCsvMappingsImport'][0]
    ): array
    {
        $request = $this->listPaymentsCsvMappingsImportRequest($employerId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\Item[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\Item[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\Item[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\Item[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\Item[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentsCsvMappingsImportAsync
     *
     * List PaymentsCsvMappings
     *
     * @param  string $employerId The Id of the Employer for which you want to list mappings (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCsvMappingsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPaymentsCsvMappingsImportAsync(
        string $employerId,
        string $contentType = self::contentTypes['listPaymentsCsvMappingsImport'][0]
    ): PromiseInterface
    {
        return $this->listPaymentsCsvMappingsImportAsyncWithHttpInfo($employerId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentsCsvMappingsImportAsyncWithHttpInfo
     *
     * List PaymentsCsvMappings
     *
     * @param  string $employerId The Id of the Employer for which you want to list mappings (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCsvMappingsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPaymentsCsvMappingsImportAsyncWithHttpInfo(
        $employerId,
        string $contentType = self::contentTypes['listPaymentsCsvMappingsImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\Item[]';
        $request = $this->listPaymentsCsvMappingsImportRequest($employerId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPaymentsCsvMappingsImport'
     *
     * @param  string $employerId The Id of the Employer for which you want to list mappings (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentsCsvMappingsImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentsCsvMappingsImportRequest(
        $employerId,
        string $contentType = self::contentTypes['listPaymentsCsvMappingsImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling listPaymentsCsvMappingsImport'
            );
        }


        $resourcePath = '/employers/{employerId}/import/payments/mappings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentsCsvMappingCsvFileImport
     *
     * Get PaymentsCsvMapping CSV File
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingCsvFileImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\ReportResponse
     */
    public function paymentsCsvMappingCsvFileImport(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingCsvFileImport'][0]
    ): \SynergiTech\Staffology\Model\ReportResponse
    {
        list($response) = $this->paymentsCsvMappingCsvFileImportWithHttpInfo($employerId, $id, $contentType);
        return $response;
    }

    /**
     * Operation paymentsCsvMappingCsvFileImportWithHttpInfo
     *
     * Get PaymentsCsvMapping CSV File
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingCsvFileImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\ReportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentsCsvMappingCsvFileImportWithHttpInfo(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingCsvFileImport'][0]
    ): array
    {
        $request = $this->paymentsCsvMappingCsvFileImportRequest($employerId, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\ReportResponse', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\ReportResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\ReportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\ReportResponse';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\ReportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentsCsvMappingCsvFileImportAsync
     *
     * Get PaymentsCsvMapping CSV File
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingCsvFileImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function paymentsCsvMappingCsvFileImportAsync(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingCsvFileImport'][0]
    ): PromiseInterface
    {
        return $this->paymentsCsvMappingCsvFileImportAsyncWithHttpInfo($employerId, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentsCsvMappingCsvFileImportAsyncWithHttpInfo
     *
     * Get PaymentsCsvMapping CSV File
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingCsvFileImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function paymentsCsvMappingCsvFileImportAsyncWithHttpInfo(
        $employerId,
        $id,
        string $contentType = self::contentTypes['paymentsCsvMappingCsvFileImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\ReportResponse';
        $request = $this->paymentsCsvMappingCsvFileImportRequest($employerId, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentsCsvMappingCsvFileImport'
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingCsvFileImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentsCsvMappingCsvFileImportRequest(
        $employerId,
        $id,
        string $contentType = self::contentTypes['paymentsCsvMappingCsvFileImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling paymentsCsvMappingCsvFileImport'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling paymentsCsvMappingCsvFileImport'
            );
        }


        $resourcePath = '/employers/{employerId}/import/payments/mappings/{id}/csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation paymentsCsvMappingImport
     *
     * Get PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\PaymentsCsvMapping
     */
    public function paymentsCsvMappingImport(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingImport'][0]
    ): \SynergiTech\Staffology\Model\PaymentsCsvMapping
    {
        list($response) = $this->paymentsCsvMappingImportWithHttpInfo($employerId, $id, $contentType);
        return $response;
    }

    /**
     * Operation paymentsCsvMappingImportWithHttpInfo
     *
     * Get PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\PaymentsCsvMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function paymentsCsvMappingImportWithHttpInfo(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingImport'][0]
    ): array
    {
        $request = $this->paymentsCsvMappingImportRequest($employerId, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\PaymentsCsvMapping', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\PaymentsCsvMapping' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\PaymentsCsvMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\PaymentsCsvMapping';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\PaymentsCsvMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation paymentsCsvMappingImportAsync
     *
     * Get PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function paymentsCsvMappingImportAsync(
        string $employerId,
        string $id,
        string $contentType = self::contentTypes['paymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        return $this->paymentsCsvMappingImportAsyncWithHttpInfo($employerId, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation paymentsCsvMappingImportAsyncWithHttpInfo
     *
     * Get PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function paymentsCsvMappingImportAsyncWithHttpInfo(
        $employerId,
        $id,
        string $contentType = self::contentTypes['paymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\PaymentsCsvMapping';
        $request = $this->paymentsCsvMappingImportRequest($employerId, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'paymentsCsvMappingImport'
     *
     * @param  string $employerId The Id of the Employer to which the PaymentCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['paymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function paymentsCsvMappingImportRequest(
        $employerId,
        $id,
        string $contentType = self::contentTypes['paymentsCsvMappingImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling paymentsCsvMappingImport'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling paymentsCsvMappingImport'
            );
        }


        $resourcePath = '/employers/{employerId}/import/payments/mappings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePaymentsCsvMappingImport
     *
     * Update PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentsCsvMapping belongs. (required)
     * @param  string $id id (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Staffology\Model\PaymentsCsvMapping
     */
    public function updatePaymentsCsvMappingImport(
        string $employerId,
        string $id,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['updatePaymentsCsvMappingImport'][0]
    ): \SynergiTech\Staffology\Model\PaymentsCsvMapping
    {
        list($response) = $this->updatePaymentsCsvMappingImportWithHttpInfo($employerId, $id, $paymentsCsvMapping, $contentType);
        return $response;
    }

    /**
     * Operation updatePaymentsCsvMappingImportWithHttpInfo
     *
     * Update PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentsCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Staffology\Model\PaymentsCsvMapping, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePaymentsCsvMappingImportWithHttpInfo(
        string $employerId,
        string $id,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['updatePaymentsCsvMappingImport'][0]
    ): array
    {
        $request = $this->updatePaymentsCsvMappingImportRequest($employerId, $id, $paymentsCsvMapping, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Staffology\Model\PaymentsCsvMapping', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Staffology\Model\PaymentsCsvMapping' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Staffology\Model\PaymentsCsvMapping', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\SynergiTech\Staffology\Model\PaymentsCsvMapping';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Staffology\Model\PaymentsCsvMapping',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePaymentsCsvMappingImportAsync
     *
     * Update PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentsCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updatePaymentsCsvMappingImportAsync(
        string $employerId,
        string $id,
        ?\SynergiTech\Staffology\Model\PaymentsCsvMapping $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['updatePaymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        return $this->updatePaymentsCsvMappingImportAsyncWithHttpInfo($employerId, $id, $paymentsCsvMapping, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePaymentsCsvMappingImportAsyncWithHttpInfo
     *
     * Update PaymentsCsvMapping
     *
     * @param  string $employerId The Id of the Employer to which the PaymentsCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updatePaymentsCsvMappingImportAsyncWithHttpInfo(
        $employerId,
        $id,
        $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['updatePaymentsCsvMappingImport'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Staffology\Model\PaymentsCsvMapping';
        $request = $this->updatePaymentsCsvMappingImportRequest($employerId, $id, $paymentsCsvMapping, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePaymentsCsvMappingImport'
     *
     * @param  string $employerId The Id of the Employer to which the PaymentsCsvMapping belongs. (required)
     * @param  string $id (required)
     * @param  \SynergiTech\Staffology\Model\PaymentsCsvMapping|null $paymentsCsvMapping (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updatePaymentsCsvMappingImport'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updatePaymentsCsvMappingImportRequest(
        $employerId,
        $id,
        $paymentsCsvMapping = null,
        string $contentType = self::contentTypes['updatePaymentsCsvMappingImport'][0]
    ): Request
    {

        // verify the required parameter 'employerId' is set
        if ($employerId === null || (is_array($employerId) && count($employerId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $employerId when calling updatePaymentsCsvMappingImport'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $id when calling updatePaymentsCsvMappingImport'
            );
        }



        $resourcePath = '/employers/{employerId}/import/payments/mappings/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($employerId !== null) {
            $resourcePath = str_replace(
                '{' . 'employerId' . '}',
                ObjectSerializer::toPathValue($employerId),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($paymentsCsvMapping)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($paymentsCsvMapping));
            } else {
                $httpBody = $paymentsCsvMapping;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
